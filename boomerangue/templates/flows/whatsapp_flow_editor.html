{% load static %}
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Editor de Fluxo do WhatsApp</title>
    <link rel="stylesheet" type="text/css" href="{% static 'assets/css/drawflow.min.css' %}">
    <link rel="stylesheet" type="text/css" href="{% static 'assets/css/beautiful.css' %}" />
    <link rel="stylesheet" type="text/css" href="{% static 'assets/css/flow.css' %}" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="{% static 'assets/js/drawflow/drawflow.min.js' %}"></script>
</head>
<body>
    <div class="page-container">
        <header>
            <h2>Editor de Fluxo - WhatsApp</h2>
            <form id="flow-form" style="display: contents;">
                 {% csrf_token %}
                 <button type="button" class="save-button" onclick="saveFlow()">
                     <i class="fas fa-save"></i> Salvar Fluxo
                 </button>
            </form>
        </header>

        <div class="flow-meta">
             <div> <label for="flow-title">T√≠tulo:</label> <input type="text" id="flow-title" name="title" form="flow-form"> </div>
             <div> <label for="flow-description">Descri√ß√£o:</label> <input type="text" id="flow-description" name="description" form="flow-form"> </div>
             <input type="hidden" id="flow-id" name="n8n_workflow_id" value="{{flow.n8n_workflow_id}}" form="flow-form">
        </div>

        <div class="wrapper">
            <div class="col-nodes">
                <h3>N√≥s Dispon√≠veis</h3>
                <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="inicio"> <i class="fas fa-play-circle"></i><span> In√≠cio</span> </div>
                <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="enviar_mensagem"> <i class="fas fa-paper-plane"></i><span> Enviar Mensagem</span> </div>
                <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="aguardar_resposta"> <i class="fas fa-clock"></i><span> Aguardar Resposta</span> </div>
                <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="condicao"> <i class="fas fa-code-branch"></i><span> Condi√ß√£o</span> </div>
                <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="definir_variavel"> <i class="fas fa-tags"></i><span> Definir Vari√°vel</span> </div>
                <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="chamada_api"> <i class="fas fa-network-wired"></i><span> Chamada de API</span> </div>
                <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="atraso"> <i class="fas fa-hourglass-half"></i><span> Atraso (Delay)</span> </div>
                <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="fim"> <i class="fas fa-stop-circle"></i><span> Fim</span> </div>
            </div>

            <div class="col-main">
                <div id="drawflow" ondrop="drop(event)" ondragover="allowDrop(event)">
                    <div class="btn-export" onclick="exportFlowData()">Export</div>
                    <div class="btn-clear" onclick="clearFlow()">Clear</div>
                    <div class="btn-lock"> <i id="lock" class="fas fa-lock" onclick="editor.editor_mode='fixed'; changeMode('lock');"></i> <i id="unlock" class="fas fa-lock-open" onclick="editor.editor_mode='edit'; changeMode('unlock');" style="display:none;"></i> </div>
                    <div class="bar-zoom"> <i class="fas fa-search-minus" onclick="editor.zoom_out()"></i> <i class="fas fa-search" onclick="editor.zoom_reset()"></i> <i class="fas fa-search-plus" onclick="editor.zoom_in()"></i> </div>
                </div>
            </div>

            <div class="col-properties" id="properties-panel">
                <div class="properties-header">
                    <h3 id="properties-title">Propriedades do N√≥</h3>
                </div>
                <div class="properties-body" id="properties-content">
                    Selecione um n√≥ para ver suas propriedades.
                </div>
                <div class="properties-footer">
                    <button type="button" class="apply-button" id="apply-changes-button" style="display: none;" onclick="applyNodeChanges()">
                        <i class="fas fa-check"></i> Aplicar Altera√ß√µes
                    </button>
                </div>
            </div>
        </div>
    </div>


    {{ flow.flow_json|default:'{}'|json_script:"flow-json-data" }}
    {{ flow.userVariables|default:'[]'|json_script:"user-variables-data" }}

    <script>
        const drawflowContainer = document.getElementById("drawflow");
        const editor = new Drawflow(drawflowContainer);
        editor.reroute = true;
        editor.reroute_fix_curvature = true;
        editor.force_first_input = false;
        const originalUpdate = editor.updateConnectionNodes;
            editor.updateConnectionNodes = function(nodeId) {
            console.log(`üõ†Ô∏è [DEBUG] Iniciando updateConnectionNodes para ${nodeId}`);
            originalUpdate.call(editor, nodeId);
            console.log(`‚úÖ [DEBUG] updateConnectionNodes conclu√≠do para ${nodeId}`);
        };
        // editor.zoom_scroll = true; // Removido - Implementa√ß√£o manual abaixo
 
        const propertiesPanel = document.getElementById('properties-panel');
        const propertiesContent = document.getElementById('properties-content');
        const propertiesTitle = document.getElementById('properties-title');
        const applyChangesButton = document.getElementById('apply-changes-button');
        const flowTitleInput = document.getElementById('flow-title');
        const flowDescriptionInput = document.getElementById('flow-description');
        const flowIdInput = document.getElementById('flow-id');
        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

        // Objeto para rastrear opera√ß√µes de arquivo pendentes em todos os n√≥s
        let pendingFileOperations = {}; // Formato: { nodeId: { file: File | null, deleteMedia: boolean, mediaFileName: string, mediaFileType: string } }

        let flowId = null;
        let flowData = null;
        let selectedNodeId = null; // Guarda o ID do n√≥ selecionado
        let tempNodeData = {}; // Guarda altera√ß√µes tempor√°rias do painel
        let availableVariables = [ // Vari√°veis de exemplo - Idealmente viriam do backend
            { name: 'contato.nome', description: 'Nome do contato' },
            { name: 'contato.telefone', description: 'Telefone do contato (WhatsApp ID)' },
            { name: 'contato.email', description: 'Email do contato' },
            { name: 'variavel.customizada', description: 'Exemplo de vari√°vel definida no fluxo' },
            { name: 'sistema.data_hora', description: 'Data e hora atuais' },
            { name: 'sistema.fluxo_id', description: 'ID do fluxo atual' },
            { name: 'api_response.status', description: 'Status da √∫ltima chamada de API' },
            { name: 'user_response', description: '√öltima resposta do usu√°rio (Aguardar Resposta)' },
        ];
        const fixedButtonOutputIds = ['output_2', 'output_3', 'output_4']; // IDs fixos para bot√µes de resposta
        let userDefinedVariables = []; // Array para armazenar vari√°veis definidas pelo usu√°rio { name: string, type: string, description?: string }
        let variableSelectorElement = null; // Refer√™ncia ao dropdown de vari√°veis
        try {
            const title = "{{ flow.title|escapejs }}" || ''; // Usar escapejs para seguran√ßa
            const description = "{{ flow.description|escapejs }}" || ''; // Usar escapejs para seguran√ßa
            // const flow_json = '{{flow.flow_json}}' || []; // Removido - Usaremos json_script
            const flow_id = "{{ flow.n8n_workflow_id|escapejs }}" || ''; // Usar escapejs para seguran√ßa
            // const userVariables = '{{flow.userVariables}}' || '' // Removido - Usaremos json_script

            // Ler dados das tags script geradas pelo json_script
            const flowJsonElement = document.getElementById('flow-json-data');
            const userVariablesElement = document.getElementById('user-variables-data');
            if (flow_id) {
                flowId = flow_id;
                flowTitleInput.value = title || '';
                flowDescriptionInput.value = description || '';
                // Processar flow_json
                if (flowJsonElement && flowJsonElement.textContent) {
                    try {
                        // Tenta parse duplo devido a poss√≠vel duplo escape vindo do backend/template
                        // Verifica primeiro se o conte√∫do j√° √© um objeto
                        let content = flowJsonElement.textContent;
                        
                        try {
                            // Se for uma string JSON v√°lida, faz o parse
                            flowData = JSON.parse(content);
                            console.log("Dados do fluxo carregados com single parse");
                        } catch (parseError) {
                            // Se falhar, pode ser que esteja duplamente escapado
                            console.warn("Primeiro parse falhou, tentando parse duplo");
                            flowData = JSON.parse(JSON.parse(content));
                            console.log("Dados do fluxo carregados com double parse");
                        }
                        
                        console.log("DEBUG: typeof flowData ap√≥s parse:", typeof flowData);
                        
                        // IMPORTANTE: Limpar Base64 dos n√≥s
                        if (flowData && flowData.drawflow && flowData.drawflow.Home && flowData.drawflow.Home.data) {
                            for (const nodeId in flowData.drawflow.Home.data) {
                                const node = flowData.drawflow.Home.data[nodeId];
                                if (node.data && node.data.mediaPreviewUrl) {
                                    console.log("Removendo mediaPreviewUrl do n√≥", nodeId);
                                    delete node.data.mediaPreviewUrl;
                                }
                            }
                        }
                    } catch (e) {
                        console.error("Erro ao fazer parse do flow_json:", e, "Conte√∫do:", flowJsonElement.textContent);
                        flowData = null; // Ou um valor padr√£o, como {} ou []
                    }
                    
                } else {
                     console.warn("Elemento flow-json-data n√£o encontrado ou vazio.");
                     flowData = null; // Ou valor padr√£o
                }

                // Processar userVariables
                userDefinedVariables = []; // Inicializa como array vazio por padr√£o
                if (userVariablesElement && userVariablesElement.textContent) {
                    try {
                        const parsedVars = JSON.parse(userVariablesElement.textContent);
                        // Verifica se o resultado do parse √© um array antes de atribuir
                        if (Array.isArray(parsedVars)) {
                            userDefinedVariables = parsedVars;
                            console.log("Vari√°veis de usu√°rio carregadas:", userDefinedVariables);
                        }
                        // Se n√£o for array (ou o parse falhou no catch), userDefinedVariables permanece como [] (definido na linha 135)
                        // O bloco else/else if anterior foi removido para simplificar.
                    } catch (e) {
                        console.error("Erro ao fazer parse das userVariables do backend:", e, "Conte√∫do:", userVariablesElement.textContent);
                        // Mant√©m userDefinedVariables como [] em caso de erro de parse
                    }
                } else {
                     console.warn("Elemento user-variables-data n√£o encontrado ou vazio. Usando array vazio para userDefinedVariables.");
                }
                 console.log("Editando fluxo existente:", flowId);
            } else {
                 console.log("Criando novo fluxo.");
            }
        } catch (e) { console.error("Erro ao processar dados do fluxo:", e); }
 
        editor.start();

        Drawflow.prototype.updateNodeElements = function(nodeId) {
            const cleanId = nodeId.replace('node-', '');
            const node = this.getNodeFromId(cleanId);

            if (node) {
                // Garante que elements seja um objeto
                if (!this.elements) this.elements = {};

                // Usa ID limpo (sem 'node-') se necess√°rio
                this.elements[cleanId] = document.getElementById(nodeId);

                // Mant√©m compatibilidade com estrutura interna do Drawflow
                this.updateConnectionNodes(nodeId);
            }
        };
        // --- Fun√ß√µes Auxiliares ---
        function escapeHTML(str) { const d = document.createElement('div'); d.appendChild(document.createTextNode(str || '')); return d.innerHTML; }
        function generateUniqueId(prefix = 'id') { return `${prefix}_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`; }

        // --- Renderiza√ß√£o Visual do N√≥ (GERA o HTML) ---
        // --- Gera√ß√£o APENAS do CONTE√öDO INTERNO do N√≥ ---
        function generateNodeInnerContentHTML(nodeId, nodeData) {
            // Tenta obter o n√≥ interno para pegar nome/classe se n√£o vier em nodeData
            const nodeElement = editor.drawflow.drawflow[editor.module]?.data[nodeId];
            const nodeName = nodeElement?.name || nodeData?.name || 'desconhecido'; // Usa nome interno como fallback

            let contentHTML = '';
            // T√≠tulo e √çcone n√£o s√£o mais necess√°rios aqui, pois esta fun√ß√£o
            // retorna apenas o conte√∫do interno para a div.box

            // --- Conte√∫do Espec√≠fico por Tipo ---
            // L√≥gica de gera√ß√£o de conte√∫do permanece a mesma, mas sem definir title/iconClass
            if (nodeName === 'enviar_mensagem') {
                let mediaPreviewHTML = '';
                
                // Prioridade de exibi√ß√£o: mediaPreviewUrl (local) > mediaUrl (servidor) > √≠cone baseado no tipo
                if (nodeData.mediaPreviewUrl && nodeData.messageType === 'image') {
                    // Preview local (Base64)
                    mediaPreviewHTML += '<div class="media-preview">';
                    mediaPreviewHTML += `<img src="${escapeHTML(nodeData.mediaPreviewUrl)}" alt="Preview Local">`;
                    mediaPreviewHTML += '</div>';
                } else if (nodeData.mediaUrl && nodeData.messageType === 'image') {
                    // URL do servidor
                    mediaPreviewHTML += '<div class="media-preview">';
                    mediaPreviewHTML += `<img src="${escapeHTML(nodeData.mediaUrl)}" alt="Preview Servidor">`;
                    mediaPreviewHTML += '</div>';
                } else if (nodeData.mediaFileName && nodeData.mediaFileType) {
                    // √çcone baseado no tipo de arquivo
                    mediaPreviewHTML += '<div class="media-preview">';
                    let fileIconClass = 'fa-file-alt'; // √çcone padr√£o
                    
                    if (nodeData.mediaFileType.startsWith('video/')) fileIconClass = 'fa-file-video';
                    else if (nodeData.mediaFileType.startsWith('audio/')) fileIconClass = 'fa-file-audio';
                    else if (nodeData.mediaFileType.includes('pdf')) fileIconClass = 'fa-file-pdf';
                    
                    mediaPreviewHTML += `<i class="fas ${fileIconClass} file-icon"></i>`;
                    mediaPreviewHTML += `<br><small>${escapeHTML(nodeData.mediaFileName)}</small>`;
                    mediaPreviewHTML += '</div>';
                } else if (nodeData.mediaUrl) {
                    // URL para arquivo sem tipo espec√≠fico
                    mediaPreviewHTML += `<div class="media-preview"><small>URL: ${escapeHTML(nodeData.mediaUrl)}</small></div>`;
                }
                
                // Resto do c√≥digo para renderizar o conte√∫do da mensagem e bot√µes
                const messageTextHTML = `<div class="message-content">${escapeHTML(nodeData.text || '')}</div>`;
                const buttonsHTML = renderDynamicButtonsHTML(nodeId, nodeData.dynamicButtons);
                contentHTML = mediaPreviewHTML + messageTextHTML + buttonsHTML;
            } else if (nodeName === 'aguardar_resposta') {
                contentHTML = `<p>${escapeHTML(nodeData.promptMessage || 'Solicitar input...')}</p><small>Salvar em: ${escapeHTML(nodeData.variableName || 'indefinido')}</small>`;
            } else if (nodeName === 'condicao') {
                // Adiciona r√≥tulos True/False dentro do box para indica√ß√£o visual
                contentHTML = `
                    <p>Se ${escapeHTML(nodeData.variable || '?')} ${escapeHTML(nodeData.operator || '?')} ${escapeHTML(nodeData.value || '?')}...</p>
                    <div class="condition-labels" style="text-align: right; margin-top: 10px; font-size: 0.9em; color: #555;">
                        <div style="margin-bottom: 20px;">True <i class="fas fa-arrow-right"></i></div>
                        <div>False <i class="fas fa-arrow-right"></i></div>
                    </div>
                `;
            } else if (nodeName === 'inicio') {
                 contentHTML = '<p>Gatilho inicial do fluxo.</p>';
            } else if (nodeName === 'definir_variavel') {
                 contentHTML = `<p>Definir ${escapeHTML(nodeData.variableName || '?')} = ...</p>`;
            } else if (nodeName === 'chamada_api') {
                 contentHTML = `<p>Chamar ${escapeHTML(nodeData.method || '?')} ${escapeHTML(nodeData.url || '?')}...</p>`;
            } else if (nodeName === 'atraso') {
                 contentHTML = `<p>Aguardar ${escapeHTML(nodeData.delayTime || '?')} ${escapeHTML(nodeData.delayUnit || '?')}...</p>`;
            } else if (nodeName === 'fim') {
                 contentHTML = '<p>Fim do caminho do fluxo.</p>';
            }
            else {
                 contentHTML = `<p>Configurar ${nodeName}...</p>`;
                 // N√£o precisamos mais buscar title/icon aqui
            }

            // Retorna APENAS o HTML do conte√∫do interno
            return contentHTML;
        }

        // --- Renderiza√ß√£o Visual COMPLETA do N√≥ (para addNode e nodeInternals.html) ---
        function generateNodeHTMLVisuals(nodeId, nodeData) {
             const nodeElement = editor.drawflow.drawflow[editor.module]?.data[nodeId];
             const nodeName = nodeElement?.name || nodeData?.name || 'desconhecido';

             // Determina T√≠tulo e √çcone (l√≥gica movida para c√°)
             let title = nodeName;
             let iconClass = 'fas fa-question-circle';
             switch(nodeName) {
                 case 'enviar_mensagem': title = 'Enviar Mensagem'; iconClass = 'fas fa-paper-plane'; break;
                 case 'aguardar_resposta': title = 'Aguardar Resposta'; iconClass = 'fas fa-clock'; break;
                 case 'condicao': title = 'Condi√ß√£o'; iconClass = 'fas fa-code-branch'; break;
                 case 'inicio': title = 'In√≠cio'; iconClass = 'fas fa-play-circle'; break;
                 case 'definir_variavel': title = 'Definir Vari√°vel'; iconClass = 'fas fa-tags'; break;
                 case 'chamada_api': title = 'Chamada de API'; iconClass = 'fas fa-network-wired'; break;
                 case 'atraso': title = 'Atraso (Delay)'; iconClass = 'fas fa-hourglass-half'; break;
                 case 'fim': title = 'Fim'; iconClass = 'fas fa-stop-circle'; break;
                 default:
                     const nodeOption = document.querySelector(`.drag-drawflow[data-node="${nodeName}"] span`);
                     if (nodeOption) title = nodeOption.textContent.trim();
                     const iconOption = document.querySelector(`.drag-drawflow[data-node="${nodeName}"] i`);
                     if (iconOption) iconClass = iconOption.className;
             }

             // Gera o conte√∫do interno chamando a fun√ß√£o auxiliar
             const innerContentHTML = generateNodeInnerContentHTML(nodeId, nodeData);

             // Gera os elementos de output para os bot√µes de resposta
             let buttonOutputsHTML = '';
             // Adiciona SEMPRE a sa√≠da padr√£o 'output_1'
             buttonOutputsHTML += `<div class="output output_1"></div>`;

             if (nodeName === 'enviar_mensagem') {
                 const replyButtons = (nodeData.dynamicButtons || []).filter(b => b.type === 'reply');
                 // Gera outputs visuais FIXOS ('output_2', 'output_3', 'output_4')
                 // com base no √çNDICE do bot√£o de RESPOSTA
                 replyButtons.forEach((button, index) => {
                     if (index < fixedButtonOutputIds.length) { // Usa fixedButtonOutputIds para limitar a 3 bot√µes
                         const fixedOutputId = fixedButtonOutputIds[index]; // Obt√©m 'output_2', 'Output_3', ou 'output_4'
                         buttonOutputsHTML += `<div class="output ${fixedOutputId}"></div>`;
                     } else {
                         console.warn(`[generateNodeHTMLVisuals] Bot√£o de resposta extra (√≠ndice ${index}) ignorado para gera√ß√£o de output visual.`);
                     }
                 });
             } else if (nodeName === 'condicao') { // Adiciona outputs para condi√ß√£o FORA do box
                 // Mantenha os nomes output_1 e output_2 para compatibilidade com Drawflow
                 buttonOutputsHTML += `<div class="output output_1"></div>`; // Output True
                 buttonOutputsHTML += `<div class="output output_2"></div>`; // Output False
             }
             // Adiciona outros outputs padr√£o se necess√°rio para outros tipos de n√≥s
 
             // Monta o HTML completo envolvendo o conte√∫do interno e os outputs
             const finalHTML = `
                <div>
                  <div class="title-box"><i class="${iconClass}"></i> ${title}</div>
                  <div class="box">
                      ${innerContentHTML}
                      <!-- Outputs removidos daqui -->
                  </div>
                  <!-- Outputs visuais s√£o adicionados aqui pelo Drawflow com base no n√∫mero de 'outputs' -->
                  <!-- Usamos output_1 para True e output_2 para False no n√≥ de condi√ß√£o -->
                </div>`;
             // console.log("FINAL HTML Gerado:", finalHTML); // Log para depura√ß√£o
             return finalHTML;
        }
 
        // Modificado para sempre gerar 3 slots de bot√£o e usar IDs de output fixos
        // Modificado para renderizar APENAS os bot√µes, sem outputs internos
        function renderDynamicButtonsHTML(nodeId, buttonsData = []) {
            let buttonsHTML = '<div class="buttons-container">';
            const existingButtons = Array.isArray(buttonsData) ? buttonsData : [];

            existingButtons.forEach(button => {
                const isUrlButton = button.type === 'url';
                // Adiciona classe 'url-button' apenas se for URL para poss√≠vel estilo espec√≠fico
                const itemClass = isUrlButton ? 'message-button url-button' : 'message-button';
                buttonsHTML += `
                    <div class="${itemClass}" id="${escapeHTML(button.id)}" data-button-id="${escapeHTML(button.id)}">
                        <span>${escapeHTML(button.text)}</span>
                        ${isUrlButton ? '<span class="url-indicator">üîó</span>' : ''}
                        <!-- Output removido daqui -->
                    </div>`;
            });

            buttonsHTML += '</div>';
            return buttonsHTML;
        }


        // --- Importa√ß√£o ---
        if (flowData) {
            // --- WORKAROUND: Pr√©-processamento para evitar erro de importa√ß√£o ---
            let originalFlowData = null; // Manter os dados originais para restaurar conex√µes
            let processedFlowData = null; // Dados modificados para importa√ß√£o inicial
            let connectionsToRestore = []; // Armazena conex√µes removidas

            try {
                originalFlowData = JSON.parse(JSON.stringify(flowData)); // Guarda c√≥pia original
                processedFlowData = JSON.parse(JSON.stringify(flowData)); // Cria c√≥pia para modificar

                // Itera sobre os n√≥s nos dados processados APENAS para remover conex√µes de bot√µes
                const nodesToProcess = processedFlowData?.drawflow?.Home?.data;
                if (nodesToProcess) {
                    for (const nodeId in nodesToProcess) {
                        const node = nodesToProcess[nodeId];

                        // Remover conex√µes das sa√≠das de bot√µes para restaura√ß√£o posterior
                        // Pr√©-processamento: Remover conex√µes E as pr√≥prias chaves output_btn_* TEMPORARIAMENTE para a importa√ß√£o.
                        if (node.name === 'enviar_mensagem' && node.outputs) {
                            const outputsToRemove = []; // Guarda chaves a remover
                            for (const outputKey in node.outputs) {
                                // Verifica se a chave √© um dos IDs fixos de bot√£o OU se come√ßa com output_btn_ (legado, para seguran√ßa)
                                const isFixedButtonOutput = fixedButtonOutputIds.includes(outputKey);
                                const isLegacyButtonOutput = outputKey.startsWith('output_btn_'); // Manter verifica√ß√£o legada por seguran√ßa? Ou remover? Remover por clareza.
                                if (isFixedButtonOutput) {
                                    const outputData = node.outputs[outputKey];
                                    // 1. Guarda conex√µes para restaurar
                                    if (outputData && Array.isArray(outputData.connections) && outputData.connections.length > 0) {
                                        outputData.connections.forEach(conn => {
                                            if (conn && typeof conn === 'object' && conn.node && conn.output) {
                                                connectionsToRestore.push({
                                                    output_id: nodeId,
                                                    output_class: outputKey, // Guarda a chave original
                                                    input_id: conn.node,
                                                    input_class: conn.output
                                                });
                                            } else {
                                                console.warn(`Pr√©-processamento: Ignorando conex√£o inv√°lida na sa√≠da ${outputKey} do n√≥ ${nodeId}:`, conn);
                                            }
                                        });
                                    }
                                    // 2. Marca a chave do output FIXO do bot√£o para remo√ß√£o do objeto a ser importado
                                    outputsToRemove.push(outputKey);
                                }
                            }
                            // 3. Remove as chaves de output FIXAS de bot√£o do objeto 'node.outputs' que ser√° importado
                            if (outputsToRemove.length > 0) {
                                outputsToRemove.forEach(key => {
                                    delete node.outputs[key];
                                    console.log(`Pr√©-processamento: Chave de output FIXA de bot√£o '${key}' removida temporariamente do n√≥ ${nodeId} para importa√ß√£o.`);
                                });
                            }
                             console.log(`Pr√©-processamento: Conex√µes de bot√£o (fixas) removidas/guardadas do n√≥ ${nodeId}. Total a restaurar: ${connectionsToRestore.length}. Outputs restantes para import:`, node.outputs ? Object.keys(node.outputs) : 'Nenhum');
                        }
                    } // Fim do loop for (const nodeId in nodesToProcess)
                }
                console.log("Pr√©-processamento (remo√ß√£o de conex√µes) conclu√≠do. Total de conex√µes a restaurar:", connectionsToRestore.length);
            } catch (preProcessError) {
                console.error("Erro durante o pr√©-processamento dos dados do fluxo (remo√ß√£o de conex√µes):", preProcessError);
                processedFlowData = JSON.parse(JSON.stringify(flowData)); // Garante que usamos uma c√≥pia limpa se o pr√©-processamento falhar
                connectionsToRestore = [];
            }
            // --- FIM WORKAROUND ---
 
            // Verifica a estrutura mais profundamente antes de tentar importar
            if (typeof processedFlowData === 'object' && processedFlowData !== null && processedFlowData.drawflow && processedFlowData.drawflow.Home && processedFlowData.drawflow.Home.data) {
                 try {
                    // Importa os dados SEM as conex√µes dos bot√µes
                    console.log("Entrou aqui", processedFlowData)
                    editor.import(originalFlowData);
                    console.log("Fluxo importado com sucesso (sem conex√µes de bot√µes iniciais).");
 
                    // --- Populate userDefinedVariables from imported nodes ---
                    console.log("[P√≥s-Import] Populando userDefinedVariables a partir dos n√≥s importados...");
                    const importedNodesData = editor.export().drawflow[editor.module].data;
                    let initialUserVarsCount = userDefinedVariables.length;
                    for (const nodeId_import in importedNodesData) { // Use different variable name to avoid conflict
                        const node_import = importedNodesData[nodeId_import];
                        if (node_import.name === 'definir_variavel' && node_import.data && node_import.data.variableName) {
                            // Use default 'string' if type is missing, provide empty description if missing
                            updateUserDefinedVariables(
                                node_import.data.variableName,
                                node_import.data.variableType || 'string',
                                node_import.data.variableDescription || ''
                            );
                        }
                        // Also consider variables from 'Aguardar Resposta' node
                        else if (node_import.name === 'aguardar_resposta' && node_import.data && node_import.data.variableName) {
                             // Assume 'string' type for user responses unless specified otherwise
                             updateUserDefinedVariables(
                                 node_import.data.variableName,
                                 'string', // Or determine type based on 'expectedType' if necessary
                                 `Resposta do usu√°rio (${nodeId_import})` // Example description
                             );
                        }
                        // Also consider variables from 'Chamada API' node
                         else if (node_import.name === 'chamada_api' && node_import.data) {
                             // Variable for the whole response
                             if (node_import.data.responseVariable) {
                                 updateUserDefinedVariables(
                                     node_import.data.responseVariable,
                                     'object', // API responses are often objects/JSON
                                     `Resposta da API (${nodeId_import})` // Example description
                                 );
                             }
                             // Variables from responseMappings
                             if (Array.isArray(node_import.data.responseMappings)) {
                                 node_import.data.responseMappings.forEach(mapping => {
                                     if (mapping.localVariable) {
                                         // Try to infer type based on API field name? Difficult. Default to string.
                                         updateUserDefinedVariables(
                                             mapping.localVariable,
                                             'string', // Default type for mapped variables
                                             `Mapeado de ${mapping.apiField} da API (${nodeId_import})`
                                         );
                                     }
                                 });
                             }
                         }
                    }
                     console.log(`[P√≥s-Import] userDefinedVariables populado. Antes: ${initialUserVarsCount}, Depois: ${userDefinedVariables.length}`);
                     // --- Fim da Popula√ß√£o ---

                    // P√≥s-importa√ß√£o: Sincroniza√ß√£o manual e restaura√ß√£o de conex√µes
                    const nodes = editor.export().drawflow[editor.module].data; // Re-fetch nodes data if needed, though export() might be stable
                    const repositionPromises = []; // Array para guardar as Promises de reposicionamento
                    for (const nodeId in nodes) {
                        const node = nodes[nodeId];
                        const nodeInternals = editor.drawflow.drawflow[editor.module].data[nodeId]; // N√≥ interno

                        // Garante que dynamicButtons seja um array
                        if (node.name === 'enviar_mensagem') {
                            if (!Array.isArray(node.data.dynamicButtons)) {
                                node.data.dynamicButtons = [];
                            }
                        }

                        // Gera o HTML COMPLETO correto com base nos dados importados
                        const correctHTML = generateNodeHTMLVisuals(nodeId, node.data);
                        nodeInternals.html = correctHTML;

                        // *** IN√çCIO: Sincroniza√ß√£o P√≥s-Importa√ß√£o (para 'enviar_mensagem') ***
                        if (node.name === 'enviar_mensagem') {
                            console.log(`[P√≥s-Import] Iniciando sincroniza√ß√£o de I/O para n√≥ ${nodeId}`);
                            const finalNodeData = node.data; // Dados importados
                            const desiredReplyButtons = (finalNodeData.dynamicButtons || []).filter(b => b.type === 'reply');

                            // --- 1. Sincronizar INPUTS ---
                            const newInputs = {};
                            // Preservar input_1 se existir, sen√£o criar um vazio
                            const input1Data = nodeInternals.inputs?.input_1 || { connections: [] };
                            // Garante que connections seja um array
                            if (!Array.isArray(input1Data.connections)) {
                                console.warn(`[P√≥s-Import ${nodeId}] Corrigindo connections inv√°lido para input_1.`);
                                input1Data.connections = [];
                            }
                            newInputs['input_1'] = input1Data;

                            // Atualiza a estrutura interna de inputs
                            nodeInternals.inputs = newInputs;
                            console.log(`[P√≥s-Import ${nodeId}] Estrutura interna 'inputs' definida:`, JSON.parse(JSON.stringify(nodeInternals.inputs)));

                            // Limpeza Manual do DOM (Inputs Visuais Extras)
                            const nodeElementInputs = document.querySelector(`#node-${nodeId} .inputs`);
                            if (nodeElementInputs) {
                                const currentVisualInputs = Array.from(nodeElementInputs.querySelectorAll(':scope > .input'));
                                console.log(`[P√≥s-Import ${nodeId}] Inputs Visuais ANTES da limpeza: ${currentVisualInputs.map(el => el.classList[el.classList.length - 1]).join(', ')}`);
                                currentVisualInputs.forEach(inputElement => {
                                    if (!inputElement.classList.contains('input_1')) {
                                        console.log(`[P√≥s-Import ${nodeId}] Removendo input visual extra: ${inputElement.classList[inputElement.classList.length - 1]}`);
                                        inputElement.remove();
                                    }
                                });
                                // Garante que input_1 exista visualmente se estiver nos dados internos
                                if (nodeInternals.inputs['input_1'] && !nodeElementInputs.querySelector(':scope > .input_1')) {
                                    console.log(`[P√≥s-Import ${nodeId}] Criando input visual input_1 ausente.`);
                                    const input1Div = document.createElement('div');
                                    input1Div.classList.add('input', 'input_1');
                                    nodeElementInputs.appendChild(input1Div);
                                }
                                console.log(`[P√≥s-Import ${nodeId}] Inputs Visuais DEPOIS da limpeza: ${Array.from(nodeElementInputs.querySelectorAll(':scope > .input')).map(el => el.classList[el.classList.length - 1]).join(', ')}`);
                            } else {
                                console.warn(`[P√≥s-Import ${nodeId}] Container de inputs visuais n√£o encontrado para limpeza.`);
                            }


                            // --- 2. Sincronizar OUTPUTS ---
                            const newOutputs = {};
                            // Preservar output_1 se existir, sen√£o criar um vazio
                            const output1Data = nodeInternals.outputs?.output_1 || { connections: [] };
                             // Garante que connections seja um array
                            if (!Array.isArray(output1Data.connections)) {
                                console.warn(`[P√≥s-Import ${nodeId}] Corrigindo connections inv√°lido para output_1.`);
                                output1Data.connections = [];
                            }
                            newOutputs['output_1'] = output1Data;

                            // Construir sa√≠das internas para bot√µes usando IDs FIXOS e mapear outputId
                            desiredReplyButtons.forEach((button, index) => {
                                if (index < fixedButtonOutputIds.length) {
                                    const fixedOutputId = fixedButtonOutputIds[index];
                                    // Cria a estrutura do output, conex√µes ser√£o restauradas depois
                                    newOutputs[fixedOutputId] = { connections: [] };
                                    button.outputId = fixedOutputId; // Mapeia o ID FIXO nos dados do bot√£o
                                    console.log(`[P√≥s-Import ${nodeId}] Output interno '${fixedOutputId}' definido para bot√£o √≠ndice ${index}`);
                                }
                            });

                            // Atualiza a estrutura interna de outputs
                            nodeInternals.outputs = newOutputs;
                            
                            console.log(`[P√≥s-Import ${nodeId}] Estrutura interna 'outputs' definida:`, JSON.parse(JSON.stringify(nodeInternals.outputs)));

                            // Atualiza os dados do n√≥ no Drawflow para garantir que os outputIds mapeados estejam salvos
                            editor.updateNodeDataFromId(nodeId, finalNodeData);

                            // A estrutura interna de outputs foi corrigida.
                            // A atualiza√ß√£o visual ser√° feita por updateConnectionNodes mais abaixo.

                            // --- 3. Reposicionamento Visual (ser√° chamado ap√≥s updateConnectionNodes) ---
                            // N√£o agendamos mais com Promise aqui.

                            // --- 4. Notificar Drawflow para Atualizar Conex√µes/Visual ---
                            // Esta fun√ß√£o deve redesenhar os pontos de input/output com base
                            // nas estruturas nodeInternals.inputs e nodeInternals.outputs que corrigimos.
                            console.log(`[P√≥s-Import ${nodeId}] Chamando updateConnectionNodes.`);
                            editor.updateConnectionNodes('node-' + nodeId);

                            // *** IN√çCIO: Reintroduzindo Sincroniza√ß√£o Manual do DOM (Outputs Visuais) P√≥s-Import ***
                            // Como a importa√ß√£o usa o HTML original, precisamos sincronizar o DOM aqui.
                            const outputsContainerSync = document.querySelector(`#node-${nodeId} .outputs`);
                            if (outputsContainerSync && nodeInternals.name === 'enviar_mensagem') { // Adiciona verifica√ß√£o de tipo de n√≥
                                const desiredOutputKeysSync = Object.keys(nodeInternals.outputs); // Inclui output_1 e os fixos (output_2, Output_3, output_4)
                                console.log(`[Sync DOM P√≥s-Import ${nodeId}] Desejados (Internos): ${desiredOutputKeysSync.join(', ')}`);

                                const currentVisualOutputElementsSync = Array.from(outputsContainerSync.querySelectorAll(':scope > .output'));
                                console.log(`[Sync DOM P√≥s-Import ${nodeId}] Visuais Atuais ANTES: ${currentVisualOutputElementsSync.map(el => el.classList[el.classList.length - 1]).join(', ')}`);

                                // 1. Remover outputs visuais que n√£o est√£o na estrutura interna (exceto output_1)
                                //    Ou que n√£o sejam os IDs fixos desejados.
                                currentVisualOutputElementsSync.forEach(visualElement => {
                                    const visualKey = Array.from(visualElement.classList).find(cls => cls !== 'output');
                                    const isFixedOutput = visualKey && fixedButtonOutputIds.includes(visualKey);
                                    const isOutput1 = visualKey === 'output_1';

                                    // Remove se N√ÉO for output_1 E N√ÉO for um dos IDs fixos desejados E N√ÉO estiver na estrutura interna atual
                                    if (!isOutput1 && visualKey && !nodeInternals.outputs[visualKey]) {
                                         console.log(`[Sync DOM P√≥s-Import ${nodeId}] Removendo output visual obsoleto/inesperado: ${visualKey}`);
                                         visualElement.remove();
                                    } else if (!isOutput1 && !isFixedOutput && visualKey) {
                                         // Remove tamb√©m se for um output inesperado (ex: output_5, output_btn_legacy)
                                         console.log(`[Sync DOM P√≥s-Import ${nodeId}] Removendo output visual com ID inesperado: ${visualKey}`);
                                         visualElement.remove();
                                    }
                                });

                                // 2. Adicionar outputs visuais FIXOS que est√£o na estrutura interna mas n√£o no DOM
                                desiredOutputKeysSync.forEach(outputKey => {
                                    // Adiciona apenas se for um dos IDs fixos ou output_1
                                    if (outputKey === 'output_1' || fixedButtonOutputIds.includes(outputKey)) {
                                        if (!outputsContainerSync.querySelector(`:scope > .${outputKey}`)) {
                                            console.log(`[Sync DOM P√≥s-Import ${nodeId}] Criando output visual ausente: ${outputKey}`);
                                            const newOutputDiv = document.createElement('div');
                                            newOutputDiv.classList.add('output', outputKey);
                                            outputsContainerSync.appendChild(newOutputDiv);
                                        }
                                    }
                                });
                                console.log(`[Sync DOM P√≥s-Import ${nodeId}] Sincroniza√ß√£o conclu√≠da. Visuais Finais: ${Array.from(outputsContainerSync.querySelectorAll(':scope > .output')).map(el => el.classList[el.classList.length - 1]).join(', ')}`);
                            } else if (nodeInternals.name === 'enviar_mensagem') { // Log apenas se for n√≥ de mensagem
                                console.error(`[Sync DOM P√≥s-Import ${nodeId}] ERRO CR√çTICO: Container de outputs visuais n√£o encontrado para sincroniza√ß√£o manual do DOM.`);
                            }
                            // *** FIM: Sincroniza√ß√£o Manual do DOM (Outputs Visuais) P√≥s-Import ***

                            // Chamar reposicionamento ap√≥s updateConnectionNodes E AP√ìS SYNC MANUAL, no pr√≥ximo frame
                            // Aumentamos o delay para garantir que o DOM esteja totalmente atualizado
                            setTimeout(() => {
                                console.log(`[P√≥s-Import ${nodeId}] Chamando repositionButtonOutputs ap√≥s timeout para garantir renderiza√ß√£o completa`);
                                try {
                                    // Verifica se todos os elementos necess√°rios est√£o presentes no DOM
                                    const nodeElement = document.querySelector(`#node-${nodeId}`);
                                    const outputsContainer = nodeElement?.querySelector('.outputs');
                                    const buttonsContainer = nodeElement?.querySelector('.buttons-container');
                                    
                                    // Verifica se todos os outputs esperados est√£o presentes
                                    if (nodeElement && outputsContainer && buttonsContainer) {
                                        const nodeData = editor.getNodeFromId(nodeId)?.data;
                                        if (nodeData && Array.isArray(nodeData.dynamicButtons)) {
                                            const replyButtons = nodeData.dynamicButtons.filter(b => b.type === 'reply');
                                            let allOutputsExist = true;
                                            
                                            // Verifica se cada bot√£o tem seu output correspondente
                                            replyButtons.forEach((btn, index) => {
                                                if (index < fixedButtonOutputIds.length) {
                                                    const outputId = fixedButtonOutputIds[index];
                                                    const outputElement = outputsContainer.querySelector(`.${outputId}`);
                                                    if (!outputElement) {
                                                        console.warn(`[P√≥s-Import ${nodeId}] Output ${outputId} n√£o encontrado para bot√£o ${btn.id}. Adiando reposicionamento.`);
                                                        allOutputsExist = false;
                                                    }
                                                }
                                            });
                                            
                                            if (allOutputsExist) {
                                                console.log(`[P√≥s-Import ${nodeId}] Todos os outputs verificados, executando repositionButtonOutputs.`);
                                                repositionButtonOutputs(nodeId);
                                            } else {
                                                console.warn(`[P√≥s-Import ${nodeId}] Nem todos os outputs est√£o presentes no DOM. Agendando reposicionamento adicional.`);
                                                // Tenta novamente ap√≥s um delay adicional
                                                setTimeout(() => {
                                                    console.log(`[P√≥s-Import ${nodeId}] √öltima tentativa de reposicionamento.`);
                                                    repositionButtonOutputs(nodeId);
                                                }, 500);
                                            }
                                        } else {
                                            repositionButtonOutputs(nodeId);
                                        }
                                    } else {
                                        console.warn(`[P√≥s-Import ${nodeId}] Elementos essenciais n√£o encontrados. Node: ${!!nodeElement}, Outputs: ${!!outputsContainer}, Buttons: ${!!buttonsContainer}`);
                                    }
                                } catch (repositionError) {
                                    console.error(`[P√≥s-Import ${nodeId}] Erro durante repositionButtonOutputs:`, repositionError);
                                }

                                // Verifica√ß√£o e limpeza de conex√µes inv√°lidas ap√≥s restaura√ß√£o
                                // Para evitar conex√µes "fantasmas" que podem causar erros
                                try {
                                    const nodeInternals = editor.getNodeFromId(nodeId);
                                    if (nodeInternals && nodeInternals.outputs) {
                                        // Iterar por todos os outputs e verificar conex√µes
                                        for (const outputKey in nodeInternals.outputs) {
                                            if (!nodeInternals.outputs[outputKey].connections) {
                                                nodeInternals.outputs[outputKey].connections = [];
                                                continue;
                                            }
                                            
                                            // Filtrar conex√µes inv√°lidas
                                            let connectionsBefore = nodeInternals.outputs[outputKey].connections.length;
                                            nodeInternals.outputs[outputKey].connections = nodeInternals.outputs[outputKey].connections.filter(conn => {
                                                // Verificar se o n√≥ de destino existe
                                                const targetNodeExists = !!editor.getNodeFromId(conn.node);
                                                // Verificar se a classe de input existe no n√≥ de destino
                                                const targetInputExists = targetNodeExists && 
                                                    editor.getNodeFromId(conn.node).inputs && 
                                                    editor.getNodeFromId(conn.node).inputs[conn.output];
                                                
                                                if (!targetNodeExists || !targetInputExists) {
                                                    console.warn(`[P√≥s-Import ${nodeId}] Removendo conex√£o inv√°lida de ${outputKey} para n√≥ ${conn.node}.${conn.output} - Destino n√£o existe`);
                                                    return false;
                                                }
                                                return true;
                                            });
                                            
                                            let connectionsAfter = nodeInternals.outputs[outputKey].connections.length;
                                            if (connectionsAfter < connectionsBefore) {
                                                console.log(`[P√≥s-Import ${nodeId}] Output ${outputKey}: ${connectionsBefore - connectionsAfter} conex√µes inv√°lidas removidas.`);
                                            }
                                        }
                                        
                                        // Atualiza as conex√µes visuais para refletir as mudan√ßas
                                        editor.updateConnectionNodes("node-"+nodeId);
                                    }
                                } catch (cleanupError) {
                                    console.error(`[P√≥s-Import ${nodeId}] Erro durante limpeza de conex√µes inv√°lidas:`, cleanupError);
                                }
                            }, 300); // Aumentamos o delay para 300ms para dar tempo ao DOM

                        }
                        // *** FIM: Sincroniza√ß√£o P√≥s-Importa√ß√£o ***
                    } // Fim do loop for (const nodeId in nodes)
                    // --- IN√çCIO: Restaura√ß√£o Global de Conex√µes de Bot√µes (Ap√≥s Loop) ---
                    // Fun√ß√£o auxiliar para esperar por um elemento no DOM usando MutationObserver
                    function waitForElement(selector, parentElement = document.body) {
                        return new Promise((resolve, reject) => {
                            const element = parentElement.querySelector(selector);
                            if (element) {
                                resolve(element);
                                return;
                            }

                            const observer = new MutationObserver(mutations => {
                                const targetElement = parentElement.querySelector(selector);
                                if (targetElement) {
                                    observer.disconnect();
                                    resolve(targetElement);
                                }
                            });

                            // Timeout de seguran√ßa
                            const timeoutId = setTimeout(() => {
                                observer.disconnect();
                                console.error(`Timeout esperando pelo elemento: ${selector}`);
                                reject(new Error(`Timeout esperando por ${selector}`));
                            }, 5000); // 5 segundos de timeout

                            observer.observe(parentElement, {
                                childList: true,
                                subtree: true
                            });
                        });
                    }

                    // Fun√ß√£o para restaurar todas as conex√µes PENDENTES (incluindo as de bot√µes com IDs fixos)
                    async function restoreAllPendingConnections(connections) {
                        if (!connections || connections.length === 0) {
                            console.log("[Restore Global] Nenhuma conex√£o pendente para restaurar.");
                            return;
                        }
                        console.log(`[Restore Global] Iniciando restaura√ß√£o de ${connections.length} conex√µes pendentes.`);

                        // 1. Esperar que todos os elementos de output e input necess√°rios existam
                        const elementPromises = [];
                        const uniqueSelectors = new Set();
                        
                        // Filtrar conex√µes v√°lidas (muitas vezes podem haver conex√µes com dados inv√°lidos)
                        const validConnections = connections.filter(conn => {
                            // Verifica se todos os campos necess√°rios existem
                            if (!conn.output_id || !conn.input_id || !conn.output_class || !conn.input_class) {
                                console.warn("[Restore Global] Conex√£o inv√°lida ignorada:", conn);
                                return false;
                            }
                            
                            // Verifica se os n√≥s de origem e destino existem
                            const outputNodeExists = editor.getNodeFromId(conn.output_id);
                            const inputNodeExists = editor.getNodeFromId(conn.input_id);
                            
                            if (!outputNodeExists || !inputNodeExists) {
                                console.warn(`[Restore Global] N√≥s n√£o encontrados para conex√£o: output=${conn.output_id}, input=${conn.input_id}`);
                                return false;
                            }
                            
                            return true;
                        });
                        
                        console.log(`[Restore Global] Ap√≥s filtragem: ${validConnections.length} conex√µes v√°lidas de ${connections.length} originais`);

                        // Para cada conex√£o v√°lida, criar seletores para os elementos DOM que devem existir
                        validConnections.forEach(conn => {
                            uniqueSelectors.add(`#node-${conn.output_id} .outputs .${conn.output_class}`);
                            uniqueSelectors.add(`#node-${conn.input_id} .inputs .${conn.input_class}`);
                        });

                        console.log("[Restore Global] Seletores √∫nicos a aguardar:", Array.from(uniqueSelectors));
                        
                        // Esperar por todos os elementos necess√°rios com timeout
                        const waitForElements = async () => {
                            const MAX_WAIT_MS = 5000; // Timeout m√°ximo de 5 segundos
                            const elementPromises = Array.from(uniqueSelectors).map(selector => {
                                return new Promise((resolve) => {
                                    // Verificar imediatamente
                                    const element = document.querySelector(selector);
                                    if (element) {
                                        resolve({ selector, element, exists: true });
                                        return;
                                    }
                                    
                                    // Se n√£o encontrou, configurar um timeout
                                    const timeoutId = setTimeout(() => {
                                        resolve({ selector, element: null, exists: false });
                                    }, MAX_WAIT_MS);
                                    
                                    // E um observer para detectar quando aparecer
                                    const observer = new MutationObserver(() => {
                                        const element = document.querySelector(selector);
                                        if (element) {
                                            clearTimeout(timeoutId);
                                            observer.disconnect();
                                            resolve({ selector, element, exists: true });
                                        }
                                    });
                                    
                                    observer.observe(document.body, {
                                        childList: true,
                                        subtree: true
                                    });
                                });
                            });
                            
                            return Promise.all(elementPromises);
                        };
                        
                        // Aguardar pelos elementos
                        const elementResults = await waitForElements();
                        
                        // Identificar elementos que n√£o foram encontrados
                        const missingElements = elementResults.filter(result => !result.exists);
                        if (missingElements.length > 0) {
                            console.warn(`[Restore Global] ${missingElements.length} elementos n√£o encontrados ap√≥s timeout:`, 
                                missingElements.map(m => m.selector).join(', '));
                        }
                        
                        // Mapeamento de seletores para elementos para uso r√°pido
                        const elementMap = {};
                        elementResults.forEach(result => {
                            if (result.exists) {
                                elementMap[result.selector] = result.element;
                            }
                        });

                        // 2. Restaurar as conex√µes uma a uma
                        console.log(`[Restore Global] Iniciando restaura√ß√£o de ${validConnections.length} conex√µes individuais...`);
                        let restoredCount = 0;
                        let failedCount = 0;

                        // Para cada conex√£o, tentar criar:
                        // 1. Primeiro tentar criar conex√£o VISUAL no DOM diretamente
                        // 2. Depois atualizar os dados internos para garantir sincronia
                        validConnections.forEach((conn, index) => {
                            const connectionId = `${index + 1}/${validConnections.length}`;
                            const outputSelector = `#node-${conn.output_id} .outputs .${conn.output_class}`;
                            const inputSelector = `#node-${conn.input_id} .inputs .${conn.input_class}`;
                            
                            const outputElement = elementMap[outputSelector];
                            const inputElement = elementMap[inputSelector];

                            try {
                                if (outputElement && inputElement) {
                                    // Verifica√ß√£o para evitar duplicatas
                                    const existingConnection = document.querySelector(
                                        `.connection.node_in_node-${conn.input_id}.node_out_node-${conn.output_id}.${conn.output_class}.${conn.input_class}`
                                    );
                                    
                                    if (existingConnection) {
                                        console.log(`[Restore Global ${connectionId}] Conex√£o visual j√° existe, pulando.`);
                                        restoredCount++;
                                        return;
                                    }
                                    
                                    // 1. Criar um elemento visual para a conex√£o
                                    try {
                                        // Criar SVG para a conex√£o
                                        const svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                                        const pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                        
                                        // Adicionar classes para identifica√ß√£o
                                        pathElement.classList.add("main-path");
                                        svgElement.classList.add("connection");
                                        svgElement.classList.add(`node_in_node-${conn.input_id}`);
                                        svgElement.classList.add(`node_out_node-${conn.output_id}`);
                                        svgElement.classList.add(conn.output_class);
                                        svgElement.classList.add(conn.input_class);
                                        
                                        // Adicionar o path ao SVG
                                        svgElement.appendChild(pathElement);
                                        
                                        // Adicionar o SVG ao precanvas
                                        editor.precanvas.appendChild(svgElement);
                                        
                                        console.log(`[Restore Global ${connectionId}] Elemento visual de conex√£o criado.`);
                                    } catch (visualError) {
                                        console.error(`[Restore Global ${connectionId}] Erro ao criar elemento visual:`, visualError);
                                    }
                                    
                                    // 2. Usar a API para adicionar a conex√£o aos dados internos
                                    try {
                                        editor.addConnection(conn.output_id, conn.input_id, conn.output_class, conn.input_class);
                                        console.log(`[Restore Global ${connectionId}] Conex√£o restaurada com sucesso.`);
                                        restoredCount++;
                                    } catch (apiError) {
                                        console.error(`[Restore Global ${connectionId}] Erro API ao restaurar:`, apiError);
                                        
                                        // 3. Se API falhar, tentar atualizar os dados internos diretamente
                                        try {
                                            const outputNode = editor.getNodeFromId(conn.output_id);
                                            const inputNode = editor.getNodeFromId(conn.input_id);
                                            
                                            if (outputNode && inputNode) {
                                                // Verificar se os outputs e inputs existem
                                                if (!outputNode.outputs[conn.output_class]) {
                                                    outputNode.outputs[conn.output_class] = { connections: [] };
                                                }
                                                
                                                if (!inputNode.inputs[conn.input_class]) {
                                                    inputNode.inputs[conn.input_class] = { connections: [] };
                                                }
                                                
                                                // Adicionar conex√µes
                                                if (!outputNode.outputs[conn.output_class].connections) {
                                                    outputNode.outputs[conn.output_class].connections = [];
                                                }
                                                
                                                if (!inputNode.inputs[conn.input_class].connections) {
                                                    inputNode.inputs[conn.input_class].connections = [];
                                                }
                                                
                                                // Adicionar a conex√£o manualmente
                                                outputNode.outputs[conn.output_class].connections.push({
                                                    node: conn.input_id,
                                                    output: conn.input_class
                                                });
                                                
                                                inputNode.inputs[conn.input_class].connections.push({
                                                    node: conn.output_id,
                                                    input: conn.output_class
                                                });
                                                
                                                console.log(`[Restore Global ${connectionId}] Conex√£o restaurada manualmente nos dados internos.`);
                                                restoredCount++;
                                            }
                                        } catch (manualError) {
                                            console.error(`[Restore Global ${connectionId}] Falha na restaura√ß√£o manual:`, manualError);
                                            failedCount++;
                                        }
                                    }
                                } else {
                                    console.error(`[Restore Global ${connectionId}] Falha ao restaurar: Elementos n√£o encontrados no momento da conex√£o (Output: ${!!outputElement}, Input: ${!!inputElement}).`);
                                    failedCount++;
                                }
                            } catch (restoreError) {
                                console.error(`[Restore Global ${connectionId}] Erro CR√çTICO ao restaurar conex√£o:`, restoreError, "Conex√£o:", conn);
                                failedCount++;
                            }
                        });

                        console.log(`[Restore Global] Restaura√ß√£o conclu√≠da. Sucesso: ${restoredCount}, Falhas: ${failedCount}.`);
                        
                        // Atualizar todas as conex√µes visuais
                        try {
                            // Precisa atualizar a visualiza√ß√£o de todos os n√≥s envolvidos
                            const affectedNodeIds = new Set();
                            validConnections.forEach(conn => {
                                affectedNodeIds.add(`node-${conn.output_id}`);
                                affectedNodeIds.add(`node-${conn.input_id}`);
                            });
                            
                            console.log(`[Restore Global] Atualizando conex√µes visuais de ${affectedNodeIds.size} n√≥s afetados.`);
                            
                            // Atualizar cada n√≥
                            affectedNodeIds.forEach(nodeId => {
                                try {
                                    editor.updateConnectionNodes(nodeId);
                                } catch (updateError) {
                                    console.error(`[Restore Global] Erro ao atualizar conex√µes do n√≥ ${nodeId}:`, updateError);
                                }
                            });
                        } catch (finalUpdateError) {
                            console.error(`[Restore Global] Erro ao atualizar conex√µes finais:`, finalUpdateError);
                        }
                        
                        // Limpa a lista global ap√≥s a tentativa de restaura√ß√£o
                        connectionsToRestore.length = 0;
                    }

                    // Chama a fun√ß√£o de restaura√ß√£o global para TODAS as conex√µes pendentes
                    restoreAllPendingConnections(connectionsToRestore);
                    // --- FIM: Restaura√ß√£o Global de Conex√µes de Bot√µes ---
                 } catch (importError) { // Catch para o try que come√ßa na linha 367
                     console.error("Erro CR√çTICO durante editor.import() ou p√≥s-processamento:", importError);
                     // Exibir mensagem de erro para o usu√°rio
                     Swal.fire({
                         icon: 'error',
                         title: 'Erro na Importa√ß√£o',
                         text: `Ocorreu um erro ao tentar carregar o fluxo: ${importError.message}. Verifique o console para detalhes.`,
                     });
                 }
             } else { // Else para o if da linha 366 (verifica√ß√£o da estrutura de processedFlowData)
                 console.error("Falha ao importar fluxo: A estrutura dos dados processados √© inv√°lida ou vazia.", processedFlowData);
                 // Exibir mensagem de erro para o usu√°rio
                 Swal.fire({
                     icon: 'error',
                     title: 'Erro na Importa√ß√£o',
                     text: 'N√£o foi poss√≠vel carregar os dados do fluxo. A estrutura parece inv√°lida.',
                 });
             }
         } else if (flowId) { // Else if para o if da linha 317 (verifica√ß√£o se flowData existe)
             // Caso onde h√° flowId mas flowData √© null/undefined (n√£o foi carregado ou parse falhou)
             console.warn("Fluxo ID presente, mas sem dados de fluxo v√°lidos para importar.");
         }
         // --- Fim da Importa√ß√£o ---

        // --- Defini√ß√£o dos N√≥s (addNodeToDrawFlow) ---
        function addNodeToDrawFlow(name, pos_x, pos_y) {
            // Adiciona verifica√ß√£o para garantir que 'editor' est√° inicializado
            if (!editor) {
                console.error("Erro: Tentativa de adicionar n√≥ antes da inicializa√ß√£o do editor.");
                return false;
            }
            if (editor.editor_mode === 'fixed') return false;
            pos_x = pos_x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)) - (editor.precanvas.getBoundingClientRect().x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)));
            pos_y = pos_y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)) - (editor.precanvas.getBoundingClientRect().y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)));

            let nodeData = {};
            let inputs = 1;
            let outputs = 1; // Padr√£o
            let nodeClass = name;

            // Define dados padr√£o e I/O
            switch (name) {
                case 'inicio': inputs = 0; outputs = 1; nodeData = {}; break;
                // N√≥ 'enviar_mensagem' volta a ter apenas 1 output padr√£o inicial
                case 'enviar_mensagem': inputs = 1; outputs = 1; nodeData = { messageType: 'text', text: '', mediaUrl: '', mediaFileName: '', mediaPreviewUrl: '', dynamicButtons: [] }; break;
                case 'aguardar_resposta': inputs = 1; outputs = 1; nodeData = { promptMessage: 'Digite sua resposta:', expectedType: 'any', variableName: 'user_response', timeoutSeconds: 300 }; break;
                // N√≥ 'condicao' tem 2 outputs fixos (true/false)
                case 'condicao': inputs = 1; outputs = 2; nodeData = { variable: '', operator: '==', value: '' }; break;
                // Adiciona 'variableType' ao n√≥ definir_variavel
                case 'definir_variavel': inputs = 1; outputs = 1; nodeData = { variableName: 'my_var', variableValue: '', variableType: 'string' }; break;
                // Adiciona 'responseMappings' ao n√≥ chamada_api
                case 'chamada_api': inputs = 1; outputs = 1; nodeData = { url: '', method: 'GET', headers: '{}', body: '{}', responseVariable: 'api_response', responseMappings: [] }; break;
                // REMOVE linha duplicada abaixo que foi adicionada por erro no diff anterior
                // case 'definir_variavel': inputs = 1; outputs = 1; nodeData = { variableName: 'my_var', variableValue: '' }; break;
                case 'chamada_api': inputs = 1; outputs = 1; nodeData = { url: '', method: 'GET', headers: '{}', body: '{}', responseVariable: 'api_response' }; break;
                case 'atraso': inputs = 1; outputs = 1; nodeData = { delayTime: 5, delayUnit: 'seconds' }; break;
                case 'fim': inputs = 1; outputs = 0; nodeData = {}; break; // N√≥ 'fim' tem entrada, mas n√£o sa√≠da
                default: console.warn("Tipo de n√≥ desconhecido:", name); return;
            }

            // Gera o HTML inicial usando a fun√ß√£o
            const tempIdForHTML = generateUniqueId('temp'); // ID tempor√°rio s√≥ para gerar HTML
            const initialHTML = generateNodeHTMLVisuals(tempIdForHTML, { ...nodeData, name: name }); // Passa nome tamb√©m

            // Adiciona o n√≥ com o HTML correto
            const newNodeId = editor.addNode(name, inputs, outputs, pos_x, pos_y, nodeClass, nodeData, initialHTML);
            console.log(`N√≥ ${name} (ID: ${newNodeId}) adicionado.`);

            // Ajuste p√≥s-cria√ß√£o APENAS para 'condicao'
            if (name === 'condicao') {
                const nodeInternals = editor.drawflow.drawflow[editor.module].data[newNodeId];
                if (nodeInternals && nodeInternals.outputs) {
                    console.log(`Outputs do n√≥ ${newNodeId} (condicao) foram mantidos como output_1 e output_2 para compatibilidade.`);
                    // N√£o renomeamos mais os outputs para manter consist√™ncia com o Drawflow
                }
            }
            // N√£o precisamos mais ajustar outputs do 'enviar_mensagem' aqui
            editor.dispatch('nodeCreated', newNodeId);
        }

        // --- Painel de Propriedades ---

        editor.on('nodeSelected', function(id) {
            selectedNodeId = id;
            const node = editor.getNodeFromId(id);
            if (!node) return;

            // Clona os dados REAIS para edi√ß√£o tempor√°ria
            tempNodeData = JSON.parse(JSON.stringify(node.data || {}));
             // Garante que dynamicButtons seja um array em tempNodeData
             if (node.name === 'enviar_mensagem' && !Array.isArray(tempNodeData.dynamicButtons)) {
                 tempNodeData.dynamicButtons = [];
             }
             delete tempNodeData.mediaFile; // Garante que n√£o haja File object persistido em tempNodeData

            propertiesPanel.classList.add('visible');
            applyChangesButton.style.display = 'block';
            propertiesContent.innerHTML = ''; // Limpa conte√∫do anterior

            // Define o t√≠tulo do painel
            try {
                 // Tenta pegar o t√≠tulo do HTML renderizado no n√≥
                 const tempDiv = document.createElement('div'); tempDiv.innerHTML = node.html;
                 const titleBox = tempDiv.querySelector('.title-box');
                 propertiesTitle.textContent = `Propriedades: ${titleBox ? titleBox.innerText.trim() : node.name} (ID: ${id})`;
            } catch (e) { propertiesTitle.textContent = `Propriedades: ${node.name} (ID: ${id})`; }

            generatePropertyFields(node, id); // Gera campos com base nos dados TEMPOR√ÅRIOS
        });

        editor.on('nodeUnselected', function() {
            // Poderia perguntar se quer descartar altera√ß√µes n√£o salvas aqui
            selectedNodeId = null;
            tempNodeData = {}; // Limpa dados tempor√°rios
            propertiesPanel.classList.remove('visible');
            applyChangesButton.style.display = 'none';
        });


        // --- Gera√ß√£o dos Campos do Painel ---
        function generatePropertyFields(node, nodeId) {
            const data = tempNodeData; // Usa dados tempor√°rios
            const form = document.createElement('form');
            form.id = `node-${nodeId}-form`;
            // Adiciona listeners para atualizar tempNodeData em tempo real
            form.addEventListener('change', handleFormChange);
            form.addEventListener('input', handleFormChange);
            // Previne submit padr√£o do form
            form.addEventListener('submit', (e) => e.preventDefault());

            switch (node.name) {
                case 'enviar_mensagem':
                    const msgSection = document.createElement('div'); msgSection.className = 'form-section';
                    msgSection.appendChild(createSelectField('Tipo Mensagem', 'messageType', data.messageType, [ { value: 'text', text: 'Texto' }, { value: 'image', text: 'Imagem' }, { value: 'video', text: 'V√≠deo' }, { value: 'audio', text: '√Åudio' }, { value: 'document', text: 'Documento' }, ], nodeId));
                    msgSection.appendChild(createTextareaField('Texto da Mensagem', 'text', data.text, true, nodeId)); // Passa nodeId

                    const mediaUploadDiv = document.createElement('div'); mediaUploadDiv.id = `media-upload-div-${nodeId}`; mediaUploadDiv.style.display = ['image', 'video', 'audio', 'document'].includes(data.messageType) ? 'block' : 'none';
                    mediaUploadDiv.appendChild(createInputField('Arquivo de M√≠dia', 'mediaFile', '', 'file', false, nodeId)); // Passa nodeId
                    const mediaPreviewProp = document.createElement('div'); mediaPreviewProp.className = 'media-preview-prop'; mediaPreviewProp.id = `media-preview-prop-${nodeId}`;
                    // Mostra preview/nome do arquivo/URL atual ao carregar o painel
                    if (data.mediaPreviewUrl && data.messageType === 'image') { mediaPreviewProp.innerHTML = `<img src="${escapeHTML(data.mediaPreviewUrl)}" alt="Preview">`; }
                    else if (data.mediaFileName && ['video', 'audio', 'document'].includes(data.messageType)) { mediaPreviewProp.innerHTML = `<small>Arquivo atual: ${escapeHTML(data.mediaFileName)}</small>`; }
                    else if (data.mediaUrl && !data.mediaFileName) { mediaPreviewProp.innerHTML = `<small>URL atual: ${escapeHTML(data.mediaUrl)}</small>`; }
                    mediaUploadDiv.appendChild(mediaPreviewProp);

                    // **Adiciona bot√£o Excluir Arquivo**
                    const deleteButtonDiv = document.createElement('div');
                    deleteButtonDiv.style.marginTop = '5px';
                    const deleteButton = document.createElement('button');
                    deleteButton.type = 'button';
                    deleteButton.textContent = 'Excluir Arquivo Anexado';
                    deleteButton.className = 'control-button remove-button'; // Reusa estilo
                    deleteButton.id = `delete-media-button-${nodeId}`;
                    // Esconde o bot√£o inicialmente se n√£o houver arquivo/URL
                    deleteButton.style.display = (data.mediaFile || data.mediaFileName || data.mediaUrl) ? 'inline-block' : 'none';
                    deleteButton.onclick = () => deleteUploadedFileHandler(nodeId);
                    deleteButtonDiv.appendChild(deleteButton);
                    mediaUploadDiv.appendChild(deleteButtonDiv);
                    // Fim adi√ß√£o bot√£o

                    msgSection.appendChild(mediaUploadDiv);

                    msgSection.appendChild(createInputField('URL da M√≠dia (Opcional/Alternativa)', 'mediaUrl', data.mediaUrl, 'url', true, nodeId)); // Passa nodeId
                    form.appendChild(msgSection);

                    // Se√ß√£o de Bot√µes Din√¢micos
                    const btnSection = document.createElement('div'); btnSection.className = 'form-section'; btnSection.innerHTML = '<h4>Bot√µes Din√¢micos</h4>';
                    const addBtnArea = document.createElement('div'); addBtnArea.className = 'button-config-area';
                    // Usar IDs √∫nicos baseados no nodeId para evitar conflitos se m√∫ltiplos pain√©is existissem (n√£o √© o caso aqui, mas boa pr√°tica)
                    addBtnArea.innerHTML = `
                        <div class="button-type-selector">
                            <label><input type="radio" name="newButtonType_${nodeId}" value="reply" checked> Resposta R√°pida</label>
                            <label><input type="radio" name="newButtonType_${nodeId}" value="url"> URL</label>
                        </div>
                        ${createInputField('Texto do Bot√£o', `newButtonText`, '', 'text', false, nodeId).innerHTML}
                        <div id="newButtonUrlDiv_${nodeId}" style="display: none;">
                            ${createInputField('URL do Bot√£o', `newButtonUrl`, '', 'url', false, nodeId).innerHTML} 
                        </div>
                    `;
                    const addButton = document.createElement('button'); addButton.type = 'button'; addButton.textContent = 'Adicionar Bot√£o'; addButton.className = 'control-button add-button'; // Adiciona classe
                    addButton.onclick = () => addDynamicButtonHandler(nodeId); // Chama handler
                    addBtnArea.appendChild(addButton); btnSection.appendChild(addBtnArea);
                    // Listener para mostrar/esconder campo URL
                    addBtnArea.querySelectorAll(`input[name="newButtonType_${nodeId}"]`).forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            document.getElementById(`newButtonUrlDiv_${nodeId}`).style.display = e.target.value === 'url' ? 'block' : 'none';
                        });
                    });

                    // Lista de bot√µes existentes
                    const currentButtonsDiv = document.createElement('div'); currentButtonsDiv.className = 'existing-buttons-list'; currentButtonsDiv.style.marginTop = '15px'; currentButtonsDiv.id = `existing-buttons-${nodeId}`;
                    (data.dynamicButtons || []).forEach(button => {
                        currentButtonsDiv.appendChild(createButtonListItem(nodeId, button)); // Cria item da lista
                    });
                    btnSection.appendChild(currentButtonsDiv);
                    form.appendChild(btnSection);
                    break;

                // Cases para outros n√≥s (sem altera√ß√µes significativas)
                case 'aguardar_resposta':
                   // Substitui input por select para variableName
                    form.appendChild(createTextareaField('Mensagem de Solicita√ß√£o', 'promptMessage', data.promptMessage, true, nodeId));
                    form.appendChild(createSelectField('Tipo Esperado', 'expectedType', data.expectedType, [ { value: 'any', text: 'Qualquer' }, { value: 'text', text: 'Texto' }, { value: 'number', text: 'N√∫mero' }, { value: 'email', text: 'Email' }, { value: 'cnpj', text: 'CNPJ (Apenas Exemplo)' } ], nodeId));
                   // Usa a nova fun√ß√£o para criar o dropdown de vari√°veis
                   form.appendChild(createVariableSelectField('Salvar Resposta Em', 'variableName', data.variableName, nodeId));
                    form.appendChild(createInputField('Timeout (segundos)', 'timeoutSeconds', data.timeoutSeconds, 'number', false, nodeId));
                    break;
                case 'condicao':
                    form.appendChild(createInputField('Vari√°vel', 'variable', data.variable, 'text', true, nodeId));
                    form.appendChild(createSelectField('Operador', 'operator', data.operator, [ { value: '==', text: 'Igual (==)' }, { value: '!=', text: 'Diferente (!=)' }, { value: '>', text: 'Maior que (>)' }, { value: '<', text: 'Menor que (<)' }, { value: '>=', text: 'Maior ou Igual (>=)' }, { value: '<=', text: 'Menor ou Igual (<=)' }, { value: 'contains', text: 'Cont√©m' }, { value: 'startsWith', text: 'Come√ßa com' }, { value: 'endsWith', text: 'Termina com' } ], nodeId));
                    form.appendChild(createInputField('Valor para Comparar', 'value', data.value, 'text', true, nodeId));
                    const outputLabels = document.createElement('div');
                    // Referencia as sa√≠das padr√£o output_1 e output_2
                    outputLabels.innerHTML = `<small>Sa√≠da 1 (Superior): Verdadeiro (True)<br>Sa√≠da 2 (Inferior): Falso (False)</small>`;
                    outputLabels.style.marginTop = '10px'; outputLabels.style.color = '#555'; form.appendChild(outputLabels);
                    break;
                case 'definir_variavel':
                    form.appendChild(createInputField('Nome da Vari√°vel', 'variableName', data.variableName, 'text', false, nodeId));
                    // Adiciona campo para tipo da vari√°vel
                    form.appendChild(createSelectField('Tipo da Vari√°vel', 'variableType', data.variableType || 'string', [
                        { value: 'string', text: 'Texto (String)' },
                        { value: 'number', text: 'N√∫mero (Number)' },
                        { value: 'boolean', text: 'Booleano (Boolean)' },
                        { value: 'date', text: 'Data/Hora (Date)' },
                        { value: 'list', text: 'Lista (List/Array)' },
                        { value: 'object', text: 'Objeto (Object/Dict)' }
                    ], nodeId));
                    form.appendChild(createTextareaField('Valor da Vari√°vel', 'variableValue', data.variableValue, true, nodeId));
                    // Adiciona campo para descri√ß√£o da vari√°vel (opcional)
                    form.appendChild(createInputField('Descri√ß√£o (Opcional)', 'variableDescription', data.variableDescription || '', 'text', false, nodeId));
                    break;
                case 'chamada_api':
                    form.appendChild(createInputField('URL', 'url', data.url, 'text', true, nodeId));
                    form.appendChild(createSelectField('M√©todo HTTP', 'method', data.method, [ { value: 'GET', text: 'GET' }, { value: 'POST', text: 'POST' }, { value: 'PUT', text: 'PUT' }, { value: 'PATCH', text: 'PATCH' }, { value: 'DELETE', text: 'DELETE' } ], nodeId));
                    form.appendChild(createTextareaField('Cabe√ßalhos (JSON)', 'headers', data.headers, true, nodeId));
                    form.appendChild(createTextareaField('Corpo da Requisi√ß√£o (JSON)', 'body', data.body, true, nodeId)); // Permite vari√°veis
                    form.appendChild(createInputField('Nome da Vari√°vel para Salvar Resposta', 'responseVariable', data.responseVariable, 'text', false, nodeId)); // N√£o permite vari√°veis no nome

                    // Bot√£o Testar Requisi√ß√£o
                    const testButtonContainer = document.createElement('div');
                    testButtonContainer.style.marginTop = '15px';
                    const testButton = document.createElement('button');
                    testButton.type = 'button';
                    testButton.textContent = 'Testar Requisi√ß√£o';
                    testButton.className = 'control-button test-api-button';
                    testButton.onclick = () => testApiCall(nodeId);
                    testButtonContainer.appendChild(testButton);
                    form.appendChild(testButtonContainer);

                    // √Årea para exibir resultado do teste
                    const testResultArea = document.createElement('div');
                    testResultArea.id = `api-test-result-${nodeId}`;
                    testResultArea.className = 'api-test-result-area';
                    testResultArea.style.marginTop = '10px';
                    testResultArea.style.padding = '10px';
                    testResultArea.style.border = '1px dashed #ccc';
                    testResultArea.style.display = 'none'; // Come√ßa escondido
                    testResultArea.innerHTML = `<h5>Resultado do Teste:</h5><pre id="api-test-result-content-${nodeId}"></pre>`; // Adiciona ID ao pre
                    form.appendChild(testResultArea);

                    // --- Se√ß√£o de Mapeamento de Resposta ---
                    const mappingSection = document.createElement('div');
                    mappingSection.className = 'form-section api-response-mapping-section';
                    mappingSection.id = `api-response-mapping-area-${nodeId}`;
                    mappingSection.style.marginTop = '20px';
                    mappingSection.style.display = 'none'; // Come√ßa escondido

                    mappingSection.innerHTML = `
                        <h4>Configura√ß√µes de Mapeamento</h4>
                        <div class="mapping-header">
                            <span>Campo da Resposta (API)</span>
                            <span>Vari√°vel Local (Fluxo)</span>
                            <button type="button" class="control-button create-variable-link" onclick="showCreateVariableModal('${nodeId}')">Criar vari√°vel</button>
                        </div>
                        <div class="mapping-rows-container" id="mapping-rows-container-${nodeId}">
                            <!-- Linhas de mapeamento ser√£o adicionadas aqui -->
                        </div>
                        <button type="button" class="control-button add-mapping-row" onclick="addManualMappingRow('${nodeId}')" style="margin-top: 10px;">
                            <i class="fas fa-plus"></i> Adicionar Mapeamento Manual
                        </button>
                    `;
                    form.appendChild(mappingSection);
                    // Carrega e exibe mapeamentos existentes ao abrir o painel
                    const existingMappings = data.responseMappings || [];
                    if (existingMappings.length > 0) {
                        mappingSection.style.display = 'block'; // Mostra a se√ß√£o se houver mapeamentos
                        renderApiResponseMapping(nodeId, null, existingMappings); // Passa mapeamentos existentes
                    } else {
                         // Mant√©m a se√ß√£o escondida mas pronta para ser populada ap√≥s teste
                         renderApiResponseMapping(nodeId, null, []); // Renderiza vazio para estrutura
                    }
                    // --- Fim Se√ß√£o de Mapeamento ---

                    break;
                case 'atraso':
                    form.appendChild(createInputField('Tempo de Atraso', 'delayTime', data.delayTime, 'number', false, nodeId));
                    form.appendChild(createSelectField('Unidade de Tempo', 'delayUnit', data.delayUnit, [ { value: 'seconds', text: 'Segundos' }, { value: 'minutes', text: 'Minutos' }, { value: 'hours', text: 'Horas' } ], nodeId));
                    break;
                case 'inicio': case 'fim':
                    form.innerHTML = '<p>Este n√≥ n√£o possui propriedades configur√°veis.</p>'; break;
                default:
                     form.innerHTML = `<p>Configura√ß√£o n√£o dispon√≠vel para o n√≥ '${node.name}'.</p>`;
            }
            propertiesContent.appendChild(form);
        }

        // Cria item da lista de bot√µes no painel de propriedades
        function createButtonListItem(nodeId, button) {
             const btnItem = document.createElement('div');
             btnItem.className = 'button-item';
             btnItem.dataset.buttonId = button.id; // Armazena o ID √∫nico do bot√£o
             const buttonTypeText = button.type === 'url' ? 'URL' : 'Resposta R√°pida';
             // Mostra o ID FIXO da sa√≠da se for bot√£o de resposta e tiver outputId mapeado
             const outputInfo = (button.type === 'reply' && button.outputId) ? `(Sa√≠da: ${button.outputId})` : '';
             const urlInfo = button.type === 'url' ? `- ${escapeHTML(button.url || '')}` : '';
             btnItem.innerHTML = `
                 <span>${escapeHTML(button.text)} (${buttonTypeText}) ${outputInfo} ${urlInfo}</span>
                 <button type="button" class="remove-button" title="Remover Bot√£o" onclick="removeDynamicButtonHandler('${nodeId}', '${button.id}')">X</button>
             `;
             return btnItem;
        }

        // --- Handler para Mudan√ßas no Formul√°rio do Painel ---
        function handleFormChange(event) {
            const target = event.target;
            // Usa dataset.baseName se existir, sen√£o o nome completo
            const name = target.dataset.baseName || target.name;
            const value = target.type === 'file' ? target.files[0] : target.value;
            const nodeId = selectedNodeId; // Pega o ID do n√≥ selecionado globalmente

            if (name && nodeId && tempNodeData) {
                // Ignora campos de adicionar bot√£o
                if (name.startsWith('newButton')) return;

                // Tratamento especial para mapeamentos (usa dataset.index)
                if (name === 'map-api-field' && target.dataset.index !== undefined) {
                    const index = parseInt(target.dataset.index, 10);
                    if (!tempNodeData.responseMappings) tempNodeData.responseMappings = [];
                    while (tempNodeData.responseMappings.length <= index) {
                        tempNodeData.responseMappings.push({ apiField: '', localVariable: '' });
                    }
                    tempNodeData.responseMappings[index].apiField = value;
                    console.log("Temp mapping updated (API Field):", index, value);
                } else if (name === 'map-local-variable' && target.dataset.index !== undefined) {
                    const index = parseInt(target.dataset.index, 10);
                    if (!tempNodeData.responseMappings) tempNodeData.responseMappings = [];
                    while (tempNodeData.responseMappings.length <= index) {
                        tempNodeData.responseMappings.push({ apiField: '', localVariable: '' });
                    }
                    tempNodeData.responseMappings[index].localVariable = value;
                    console.log("Temp mapping updated (Local Var):", index, value);
                } else {
                    // L√≥gica padr√£o para outros campos
                    tempNodeData[name] = value;
                }
                console.log("Temp data updated:", name, value);

                // L√≥gica espec√≠fica para campos
                if (name === 'messageType') {
                    const mediaDiv = document.getElementById(`media-upload-div-${nodeId}`);
                    if (mediaDiv) mediaDiv.style.display = ['image', 'video', 'audio', 'document'].includes(value) ? 'block' : 'none';
                    // Se mudar para texto, limpa dados de m√≠dia tempor√°rios
                    if (value === 'text') {
                        delete tempNodeData.mediaFile;
                        delete tempNodeData.mediaPreviewUrl;
                        delete tempNodeData.mediaFileName;
                        // Limpa tamb√©m o input file e o preview no painel
                        const fileInput = document.querySelector(`input[data-base-name="mediaFile"][id^="prop-${nodeId}"]`);
                        if(fileInput) fileInput.value = null;
                        const previewProp = document.getElementById(`media-preview-prop-${nodeId}`);
                        if(previewProp) previewProp.innerHTML = '';
                    }
                    // Re-renderiza o preview no painel ao mudar tipo
                    const previewProp = document.getElementById(`media-preview-prop-${nodeId}`);
                    if(previewProp) previewProp.innerHTML = ''; // Limpa preview antigo
                }
                else if (name === 'mediaFile' && value instanceof File) {
                     const reader = new FileReader();
                     const fileType = value.type; // Guarda o tipo
                     tempNodeData['mediaFileType'] = fileType; // **Guarda o tipo do arquivo**
                     reader.onload = (e) => {
                         tempNodeData['mediaPreviewUrl'] = e.target.result; // Guarda Data URL para preview
                         tempNodeData['mediaFileName'] = value.name; // Guarda nome original
                         console.log("Media preview URL generated for", value.name);
                         // Atualiza preview no painel IMEDIATAMENTE
                         const previewProp = document.getElementById(`media-preview-prop-${nodeId}`);
                         const deleteBtn = document.getElementById(`delete-media-button-${nodeId}`);
                         if(previewProp && tempNodeData.messageType === 'image' && fileType.startsWith('image/')) { // Verifica tipo antes de mostrar img
                             previewProp.innerHTML = `<img src="${escapeHTML(e.target.result)}" alt="Preview">`;
                         } else if (previewProp) { // **Exibe √≠cone para outros tipos**
                                let fileIconClass = 'fa-file-alt';
                                if (fileType.startsWith('video/')) fileIconClass = 'fa-file-video';
                                else if (fileType.startsWith('audio/')) fileIconClass = 'fa-file-audio';
                                else if (fileType.includes('pdf')) fileIconClass = 'fa-file-pdf';
                                previewProp.innerHTML = `<i class="fas ${fileIconClass} file-icon"></i> <small>Arquivo atual: ${escapeHTML(value.name)}</small>`;
                          }
                          if (deleteBtn) deleteBtn.style.display = 'inline-block'; // Mostra bot√£o excluir
                     };
                     reader.onerror = (e) => {
                         console.error("FileReader error:", e);
                         delete tempNodeData.mediaFile; // Remove o arquivo problem√°tico
                         Swal.fire('Erro', 'N√£o foi poss√≠vel ler o arquivo selecionado.', 'error');
                         // Limpa preview no painel
                         const previewProp = document.getElementById(`media-preview-prop-${nodeId}`);
                         if(previewProp) previewProp.innerHTML = '<small style="color: red;">Erro ao ler arquivo.</small>';
                     };

                     // L√™ como Data URL apenas para imagens (para preview)
                     if (fileType.startsWith('image/')) {
                         reader.readAsDataURL(value);
                     }
                     // Para outros tipos, apenas guarda o nome e indica sele√ß√£o
                     // **Atualizado para incluir mais tipos comuns**
                     else if (['video', 'audio', 'pdf', 'word', 'excel', 'powerpoint', 'text', 'document', 'sheet', 'presentation', 'zip', 'rar'].some(t => fileType.includes(t))) {
                         tempNodeData['mediaPreviewUrl'] = null; // N√£o gera preview Data URL
                         tempNodeData['mediaFileName'] = value.name;
                         tempNodeData['mediaFileType'] = fileType; // **Garante que o tipo est√° guardado**
                         console.log("Stored filename and type for", value.name, fileType);
                         const previewProp = document.getElementById(`media-preview-prop-${nodeId}`);
                         const deleteBtn = document.getElementById(`delete-media-button-${nodeId}`);
                         if(previewProp) {
                             let fileIconClass = 'fa-file-alt';
                             if (fileType.startsWith('video/')) fileIconClass = 'fa-file-video';
                             else if (fileType.startsWith('audio/')) fileIconClass = 'fa-file-audio';
                             else if (fileType.includes('pdf')) fileIconClass = 'fa-file-pdf';
                             previewProp.innerHTML = `<i class="fas ${fileIconClass} file-icon"></i> <small>Selecionado: ${escapeHTML(value.name)}</small>`;
                         }
                         if (deleteBtn) deleteBtn.style.display = 'inline-block'; // Mostra bot√£o excluir
                         // N√£o precisa chamar reader.readAs... para esses tipos
                     } else {
                          console.warn("Tipo de arquivo n√£o suportado:", fileType);
                          target.value = null; // Limpa o input file
                          delete tempNodeData.mediaFile; // Remove do temp data
                          Swal.fire('Aviso', 'Tipo de arquivo n√£o suportado para upload direto. Considere usar a op√ß√£o de URL.', 'warning');
                          const previewProp = document.getElementById(`media-preview-prop-${nodeId}`);
                          const deleteBtn = document.getElementById(`delete-media-button-${nodeId}`);
                          if(previewProp) previewProp.innerHTML = '<small style="color: orange;">Tipo n√£o suportado.</small>';
                          if (deleteBtn) deleteBtn.style.display = 'none'; // Esconde bot√£o excluir
                          return; // Interrompe processamento adicional para este arquivo
                     }
                     // Ao selecionar um arquivo, limpa a URL alternativa e seu input
                     tempNodeData.mediaUrl = '';
                     tempNodeData.deleteMedia = false; // Garante que n√£o marcar√° para deletar m√≠dia existente se carregar nova
                     const urlInput = document.querySelector(`input[data-base-name="mediaUrl"][id^="prop-${nodeId}"]`);
                     if(urlInput) urlInput.value = '';
                } else if (name === 'mediaUrl' && value) {
                     // Ao digitar uma URL, limpa dados do arquivo selecionado
                     delete tempNodeData.mediaFile;
                     delete tempNodeData.mediaPreviewUrl;
                     delete tempNodeData.mediaFileName;
                     delete tempNodeData.mediaFileType;
                     tempNodeData.deleteMedia = false; // Garante que n√£o marcar√° para deletar
                     const fileInput = document.querySelector(`input[data-base-name="mediaFile"][id^="prop-${nodeId}"]`);
                     if(fileInput) fileInput.value = null;
                     // Atualiza preview no painel para mostrar a URL
                     const previewProp = document.getElementById(`media-preview-prop-${nodeId}`);
                     const deleteBtn = document.getElementById(`delete-media-button-${nodeId}`);
                     if(previewProp) previewProp.innerHTML = `<small>URL: ${escapeHTML(value)}</small>`;
                     if (deleteBtn) deleteBtn.style.display = 'inline-block'; // Mostra bot√£o excluir
                 }
            }
        }

function applyNodeChanges() {
    if (!selectedNodeId || !tempNodeData) {
        console.error("Nenhum n√≥ selecionado ou dados tempor√°rios ausentes.");
        return;
    }

    const nodeInternals = editor.drawflow.drawflow[editor.module].data[selectedNodeId];
    if (!nodeInternals) {
        console.error("N√≥ interno n√£o encontrado para ID:", selectedNodeId);
        return;
    }


    // --- IN√çCIO: Processamento da exclus√£o de bot√µes e suas conex√µes ---
    if (tempNodeData.buttonsMarkedForDeletion && tempNodeData.buttonsMarkedForDeletion.length > 0) {
        console.log(`[ApplyChanges] Processando ${tempNodeData.buttonsMarkedForDeletion.length} bot√µes marcados para exclus√£o...`);

        // Copia a lista para evitar problemas ao modificar tempNodeData dentro do loop
        const buttonsToDelete = [...tempNodeData.buttonsMarkedForDeletion];
        // Limpa a marca√ß√£o original imediatamente
        tempNodeData.buttonsMarkedForDeletion = [];

        buttonsToDelete.forEach(buttonInfo => {
            const buttonId = buttonInfo.id;
            const outputIdToRemove = buttonInfo.outputId; // Ex: 'output_2'
            const outputNodeId = selectedNodeId; // Ex: '2' (ID do n√≥ 'enviar_mensagem')

            console.log(`[ApplyChanges] Processando exclus√£o do bot√£o ${buttonId} e output ${outputIdToRemove} do n√≥ ${outputNodeId}`);

            if (!outputIdToRemove) {
                console.warn(`   [ApplyChanges] Bot√£o ${buttonId} n√£o tinha outputId associado. Apenas removendo dos dados.`);
                // Apenas remove o bot√£o dos dados, sem tentar remover conex√µes/outputs inexistentes
                if (tempNodeData.dynamicButtons && Array.isArray(tempNodeData.dynamicButtons)) {
                    tempNodeData.dynamicButtons = tempNodeData.dynamicButtons.filter(b => b.id !== buttonId);
                }
                return; // Pula para o pr√≥ximo bot√£o
            }

            // 1. Encontrar conex√µes existentes INSPECIONANDO os INPUTS de TODOS os n√≥s
            const foundConnections = [];
            const allNodesData = editor.drawflow.drawflow[editor.module].data;
            console.log(`   [ApplyChanges] Procurando conex√µes para ${outputNodeId}.${outputIdToRemove} em ${Object.keys(allNodesData).length} n√≥s.`);

            for (const targetNodeId in allNodesData) {
                // N√£o precisa verificar o pr√≥prio n√≥ de origem
                if (targetNodeId === outputNodeId) continue;

                const targetNodeInternals = allNodesData[targetNodeId];
                if (targetNodeInternals.inputs) {
                    for (const targetInputKey in targetNodeInternals.inputs) {
                        const inputData = targetNodeInternals.inputs[targetInputKey];
                        if (inputData && Array.isArray(inputData.connections)) {
                            // Verifica se alguma conex√£o neste input VEM do output que estamos removendo
                            const connectionIndex = inputData.connections.findIndex(conn =>
                                conn.node === outputNodeId && conn.input === outputIdToRemove
                            );

                            if (connectionIndex !== -1) {
                                // Encontrou uma conex√£o!
                                console.log(`      [ApplyChanges] Encontrada conex√£o: ${outputNodeId}.${outputIdToRemove} -> ${targetNodeId}.${targetInputKey}`);
                                foundConnections.push({
                                    targetNodeId: targetNodeId,
                                    targetInputKey: targetInputKey,
                                });
                                // N√ÉO removemos daqui ainda, faremos no pr√≥ximo passo
                            }
                        }
                    }
                }
            }
            console.log(`   [ApplyChanges] Total de ${foundConnections.length} conex√µes encontradas para remover.`);

            // 2. Iterar sobre as conex√µes encontradas e processar a remo√ß√£o
            if (foundConnections.length > 0) {
                 console.log(`   [ApplyChanges] Iniciando processamento de remo√ß√£o para ${foundConnections.length} conex√µes.`);
                 foundConnections.forEach(item => {
                    const targetNodeId = item.targetNodeId;
                    const targetInputKey = item.targetInputKey;
                    const connectionSelector = `.connection.node_out_node-${outputNodeId}.${outputIdToRemove}.node_in_node-${targetNodeId}.${targetInputKey}`;

                    // 2.1 Tentar remover a conex√£o l√≥gica via API
                    console.log(`      [ApplyChanges] Tentando API removeSingleConnection: ${outputNodeId}.${outputIdToRemove} -> ${targetNodeId}.${targetInputKey}`);
                    try {
                        editor.removeSingleConnection(outputNodeId, targetNodeId, outputIdToRemove, targetInputKey);
                        console.log(`         ‚úÖ [ApplyChanges] API removeSingleConnection SUCESSO.`);
                    } catch (removeApiError) {
                        console.warn(`         ‚ö†Ô∏è [ApplyChanges] API removeSingleConnection falhou (possivelmente OK se j√° removida):`, removeApiError);
                    }

                    // 2.2 Remover a conex√£o VISUAL (SVG)
                    const connectionElement = document.querySelector(connectionSelector);
                    if (connectionElement) {
                        try {
                            connectionElement.remove();
                            console.log(`      üóëÔ∏è [ApplyChanges] Elemento visual da conex√£o removido: ${connectionSelector}`);
                        } catch (removeVisualError) {
                            console.error(`      ‚ùå [ApplyChanges] Erro ao remover conex√£o visual:`, removeVisualError);
                        }
                    } else {
                        console.warn(`      ‚ùì [ApplyChanges] Elemento visual da conex√£o n√£o encontrado: ${connectionSelector}`);
                    }

                    // 2.3 **Fallback/Verifica√ß√£o**: Limpar manualmente a conex√£o do input do n√≥ de destino
                    try {
                        // Usamos allNodesData que j√° temos, em vez de getNodeFromId que pode ser menos confi√°vel aqui
                        const targetNode = allNodesData[targetNodeId];
                        if (targetNode && targetNode.inputs && targetNode.inputs[targetInputKey] && Array.isArray(targetNode.inputs[targetInputKey].connections)) {
                            const connIndex = targetNode.inputs[targetInputKey].connections.findIndex(c =>
                                c.node === outputNodeId && c.input === outputIdToRemove);

                            if (connIndex !== -1) {
                                // Modifica diretamente a estrutura interna que iteramos
                                targetNode.inputs[targetInputKey].connections.splice(connIndex, 1);
                                console.log(`      üßπ [ApplyChanges] Verificada/Removida conex√£o manualmente no n√≥ de destino ${targetNodeId}.${targetInputKey}`);
                            }
                        }
                    } catch (cleanError) {
                        console.error(`      ‚ùå [ApplyChanges] Erro ao limpar conex√£o de fallback no destino:`, cleanError);
                    }
                 });
                 console.log(`   [ApplyChanges] Fim do loop de processamento de remo√ß√£o.`);
            }

            // 3. Limpar o array de conex√µes no output do N√ì DE ORIGEM (redundante agora, mas seguro)
            if (nodeInternals.outputs && nodeInternals.outputs[outputIdToRemove]) {
                 nodeInternals.outputs[outputIdToRemove].connections = [];
                 console.log(`   üßπ [ApplyChanges] Array de conex√µes do output ${outputIdToRemove} no n√≥ de origem limpo (por seguran√ßa).`);
            }

            // 4. Remover o elemento visual do output (o ponto no n√≥ de origem)
            const outputElement = document.querySelector(`#node-${outputNodeId} .outputs .${outputIdToRemove}`);
            if (outputElement) {
                try {
                    outputElement.remove();
                    console.log(`   üóëÔ∏è [ApplyChanges] Elemento visual do output ${outputIdToRemove} removido com sucesso.`);
                } catch (removeElementError) {
                    console.error(`   ‚ùå [ApplyChanges] Erro ao remover elemento visual do output:`, removeElementError);
                }
            }

            // 5. Por fim, remover o output da estrutura de dados interna do n√≥ de origem
            try {
                editor.removeNodeOutput(outputNodeId, outputIdToRemove);
                console.log(`   üóëÔ∏è [ApplyChanges] Output ${outputIdToRemove} removido com sucesso via API do n√≥ de origem.`);
            } catch (removeOutputError) {
                console.warn(`   ‚ö†Ô∏è [ApplyChanges] Erro ao remover output via API do n√≥ de origem, removendo manualmente:`, removeOutputError);
                try {
                    if (nodeInternals.outputs) {
                         delete nodeInternals.outputs[outputIdToRemove];
                         console.log(`      üßπ [ApplyChanges] Output ${outputIdToRemove} removido manualmente dos dados internos do n√≥ de origem.`);
                    }
                } catch (manualRemoveError) {
                    console.error(`      ‚ùå [ApplyChanges] Falha na remo√ß√£o manual do output do n√≥ de origem:`, manualRemoveError);
                }
            }

             // 6. Filtrar o bot√£o da lista de dados tempor√°rios (AP√ìS processar conex√µes/outputs)
             if (tempNodeData.dynamicButtons && Array.isArray(tempNodeData.dynamicButtons)) {
                 tempNodeData.dynamicButtons = tempNodeData.dynamicButtons.filter(b => b.id !== buttonId);
                 console.log(`   [ApplyChanges] Bot√£o ${buttonId} removido de tempNodeData.dynamicButtons.`);
             }

        }); // Fim do loop buttonsToDelete.forEach

        // 7. For√ßa a atualiza√ß√£o visual dos n√≥s afetados AP√ìS processar TODOS os bot√µes marcados
        

    } // --- FIM: Processamento da exclus√£o de bot√µes ---

        requestAnimationFrame(() => {
            try {
                // Atualiza n√≥ de origem
                editor.updateConnectionNodes("node-"+selectedNodeId);
                console.log(`üîÑ [ApplyChanges] updateConnectionNodes chamado para n√≥ de origem ${selectedNodeId} (p√≥s-loop)`);

                // Atualiza n√≥s de destino que tiveram conex√µes removidas (usa Set para evitar duplicatas)
                const targetNodesToUpdate = new Set();
                
                 // Para simplificar e garantir: Atualizar todos os n√≥s que *poderiam* ter sido afetados
                const allNodes = editor.export().drawflow[editor.module].data;
                for (const nodeId in allNodes) {
                    if (nodeId !== selectedNodeId) { // J√° atualizamos o de origem
                        try {
                            editor.updateConnectionNodes("node-"+nodeId);
                        } catch (updateTargetError) {
                            // Loga mas continua
                            console.error(`      ‚ùå [ApplyChanges] Erro ao atualizar n√≥ de destino ${nodeId} (p√≥s-loop):`, updateTargetError);
                        }
                    }
                }
                console.log(`üîÑ [ApplyChanges] updateConnectionNodes chamado para outros n√≥s (p√≥s-loop)`);


            } catch (updateError) {
                console.error(`‚ùå [ApplyChanges] Erro geral ao atualizar conex√µes ap√≥s remo√ß√£o (p√≥s-loop):`, updateError);
            }
        });
    // --- IN√çCIO: Aplica√ß√£o normal das outras propriedades do n√≥ ---
    const finalNodeData = JSON.parse(JSON.stringify(tempNodeData));
    // Limpa dados tempor√°rios que n√£o devem ser salvos no n√≥
    delete finalNodeData.mediaFile;
    delete finalNodeData.buttonsMarkedForDeletion; // J√° processado acima
    // delete finalNodeData.mediaPreviewUrl;

    // Garante que input_1 exista (c√≥digo de seguran√ßa)
    if (!nodeInternals.inputs || !nodeInternals.inputs['input_1']) {
        console.warn(`Input 'input_1' ausente no n√≥ ${selectedNodeId}. Recriando.`);
        const existingInputConnections = (nodeInternals.inputs && nodeInternals.inputs['input_1'] && Array.isArray(nodeInternals.inputs['input_1'].connections))
            ? nodeInternals.inputs['input_1'].connections : [];
        if (typeof nodeInternals.inputs !== 'object' || nodeInternals.inputs === null) { nodeInternals.inputs = {}; }
        nodeInternals.inputs['input_1'] = { connections: existingInputConnections };
    } else {
        if (!Array.isArray(nodeInternals.inputs['input_1'].connections)) {
            console.warn(`Propriedade connections ausente ou inv√°lida em input_1 do n√≥ ${selectedNodeId}. Corrigindo.`);
            nodeInternals.inputs['input_1'].connections = [];
        }
    }

    // Atualiza visual interno do n√≥ (sem os outputs/inputs visuais)
    const innerContentHTML = generateNodeInnerContentHTML(selectedNodeId, finalNodeData);
    const nodeElement = document.querySelector(`#node-${selectedNodeId}`);
    const contentArea = nodeElement?.querySelector('.box');
    if (contentArea) {
        contentArea.innerHTML = innerContentHTML;
    } else {
        console.warn("√Årea de conte√∫do '.box' n√£o encontrada no n√≥:", selectedNodeId);
    }

    // Atualiza o HTML completo na estrutura interna (inclui t√≠tulo, box, etc.)
    // NOTA: Os outputs/inputs visuais S√ÉO gerenciados pelo Drawflow e por `updateConnectionNodes`
    const completeHTML = generateNodeHTMLVisuals(selectedNodeId, finalNodeData);
    nodeInternals.html = completeHTML;

    // Sincroniza a estrutura interna de outputs/inputs para n√≥s 'enviar_mensagem'
    // (Importante AP√ìS a remo√ß√£o de outputs ter sido conclu√≠da acima)
    if (nodeInternals.name === 'enviar_mensagem') {
        const desiredReplyButtons = (finalNodeData.dynamicButtons || []).filter(b => b.type === 'reply');
        const newOutputsInternal = {}; // Recria a estrutura de outputs

        // Mant√©m output_1
        const output1Data = nodeInternals.outputs?.output_1 || { connections: [] };
        if (!Array.isArray(output1Data.connections)) output1Data.connections = [];
        newOutputsInternal['output_1'] = output1Data;

        // Adiciona outputs para bot√µes de resposta restantes
        desiredReplyButtons.forEach((button, index) => {
            if (index < fixedButtonOutputIds.length) {
                const fixedOutputId = fixedButtonOutputIds[index];
                // Pega dados existentes SE AINDA EXISTIREM ap√≥s a limpeza anterior, sen√£o cria vazio
                const existingOutputData = nodeInternals.outputs?.[fixedOutputId] || { connections: [] };
                if (!Array.isArray(existingOutputData.connections)) existingOutputData.connections = [];
                newOutputsInternal[fixedOutputId] = existingOutputData;
                button.outputId = fixedOutputId; // Garante mapeamento
            }
        });

        console.log(`[ApplyChanges] Sincronizando outputs internos para ${selectedNodeId}:`, newOutputsInternal);
        nodeInternals.outputs = newOutputsInternal; // Atualiza a estrutura interna

        // --- IN√çCIO: Sincroniza√ß√£o Manual do DOM dos Outputs (Adicionar Ausentes) ---
        // Garante que os elementos visuais <div class="output output_x"> existam para os outputs definidos nos dados
        const outputsContainer = document.querySelector(`#node-${selectedNodeId} .outputs`);
        if (outputsContainer) {
            const desiredOutputKeys = Object.keys(nodeInternals.outputs);
            console.log(`   [ApplyChanges DOM Sync] Outputs desejados (dados): ${desiredOutputKeys.join(', ')}`);

            desiredOutputKeys.forEach(outputKey => {
                // Verifica se o elemento visual para este output J√Å existe
                if (!outputsContainer.querySelector(`:scope > .${outputKey}`)) {
                    // N√£o existe? Cria!
                    console.log(`      [ApplyChanges DOM Sync] Criando elemento visual para output ausente: ${outputKey}`);
                    const newOutputDiv = document.createElement('div');
                    newOutputDiv.classList.add('output', outputKey);
                    // Adiciona ao container (a ordem exata pode precisar de ajuste se importar)
                    // Adicionar output_1 no in√≠cio, outros no fim para consist√™ncia
                    if (outputKey === 'output_1' && outputsContainer.firstChild) {
                         outputsContainer.insertBefore(newOutputDiv, outputsContainer.firstChild);
                    } else {
                         outputsContainer.appendChild(newOutputDiv);
                    }
                }
            });
             // Opcional: Remover outputs visuais que N√ÉO est√£o mais em nodeInternals.outputs (embora a exclus√£o j√° deva ter feito isso)
             // const currentVisualOutputs = outputsContainer.querySelectorAll(':scope > .output');
             // currentVisualOutputs.forEach(visualEl => {
             //     const key = Array.from(visualEl.classList).find(c => c !== 'output');
             //     if (key && !nodeInternals.outputs[key]) {
             //         console.log(`      [ApplyChanges DOM Sync] Removendo output visual obsoleto: ${key}`);
             //         visualEl.remove();
             //     }
             // });
        } else {
            console.warn(`   [ApplyChanges DOM Sync] Container de outputs n√£o encontrado para n√≥ ${selectedNodeId}`);
        }
        // --- FIM: Sincroniza√ß√£o Manual do DOM dos Outputs ---

        // A atualiza√ß√£o visual dos pontos de output/input deve ser feita por updateConnectionNodes chamado no requestAnimationFrame
    }

    // Atualiza os dados do n√≥ no Drawflow (guarda finalNodeData)
    editor.updateNodeDataFromId(selectedNodeId, finalNodeData);
    console.log(`[ApplyChanges] Dados finais aplicados para n√≥ ${selectedNodeId}:`, finalNodeData);

    // Atualiza lista de vari√°veis se for o caso
    if (nodeInternals.name === 'definir_variavel' && finalNodeData.variableName) {
        updateUserDefinedVariables(finalNodeData.variableName, finalNodeData.variableType || 'string', finalNodeData.variableDescription || '');
        refreshAllVariableSelects(finalNodeData.variableName);
    }

    // Reposiciona bot√µes se for 'enviar_mensagem' (no pr√≥ximo frame)
    if (nodeInternals.name === 'enviar_mensagem') {
        requestAnimationFrame(() => {
            try {
                console.log(`[ApplyChanges] Chamando repositionButtonOutputs para ${selectedNodeId} (via rAF p√≥s-aplicar)`);
                repositionButtonOutputs(selectedNodeId);
            } catch (repositionError) {
                console.error(`[ApplyChanges ${selectedNodeId}] Erro durante repositionButtonOutputs (chamado via rAF):`, repositionError);
            }
        });
    }

    // --- FIM: Aplica√ß√£o normal ---
    // delete finalNodeData.mediaPreviewUrl;

    Swal.fire({ icon: 'success', title: 'Altera√ß√µes aplicadas!', showConfirmButton: false, timer: 1200 });
}


        // Fun√ß√£o para observar mudan√ßas no DOM e chamar o reposicionamento - REMOVIDA
        /* function observeAndRepositionOutputs(nodeId) { ... } */

        // Fun√ß√£o para reposicionar as sa√≠das dos bot√µes (baseada em √≠ndice e IDs fixos)
        // REINTRODUZIDA
        function repositionButtonOutputs(nodeId) {
            try {
                if (!nodeId) {
                    console.warn(`[repositionButtonOutputs] Chamada sem nodeId definido`);
                    return;
                }

                // Buscar elementos no DOM
                const nodeElement = document.querySelector(`#node-${nodeId}`);
                if (!nodeElement) {
                    console.warn(`[repositionButtonOutputs] N√≥ #node-${nodeId} n√£o encontrado no DOM`);
                    return;
                }

                // Pega os dados mais recentes do n√≥
                const nodeData = editor.getNodeFromId(nodeId)?.data;
                const nodeInternals = editor.getNodeFromId(nodeId); // Pega o n√≥ interno para verificar o tipo

                if (!nodeData || !nodeInternals || nodeInternals.name !== 'enviar_mensagem') {
                    // console.warn(`[repositionButtonOutputs] N√≥ ${nodeId} inv√°lido ou n√£o √© 'enviar_mensagem'.`); // Log pode ser muito verboso
                    return;
                }

                const buttonsContainer = nodeElement.querySelector('.buttons-container');
                const outputsContainer = nodeElement.querySelector('.outputs'); // Container onde Drawflow desenha as sa√≠das
                if (!buttonsContainer || !outputsContainer) {
                    console.warn(`[repositionButtonOutputs] Container de bot√µes ou sa√≠das n√£o encontrado no n√≥ ${nodeId}.`);
                    return;
                }

                // Filtra apenas os bot√µes de RESPOSTA que devem ter um output associado
                const replyButtons = (nodeData.dynamicButtons || []).filter(b => b.type === 'reply');
                // console.log(`[repositionButtonOutputs] Encontrados ${replyButtons.length} bot√µes de resposta para alinhar outputs.`);

                replyButtons.forEach((button, index) => {
                    // Verifica se o √≠ndice est√° dentro do limite
                    if (index >= fixedButtonOutputIds.length) {
                        console.warn(`[repositionButtonOutputs] √çndice de bot√£o ${index} excede o n√∫mero de outputs fixos dispon√≠veis (${fixedButtonOutputIds.length})`);
                        return; // Skip this button if index is out of range
                    }

                    // Encontra o elemento visual do bot√£o pelo seu ID √∫nico
                    const buttonElement = buttonsContainer.querySelector(`[data-button-id="${button.id}"]`);
                    if (!buttonElement) {
                        console.warn(`[repositionButtonOutputs] Elemento de bot√£o com data-button-id="${button.id}" n√£o encontrado`);
                        return; // Skip this button if button element not found
                    }

                    // Determina o ID FIXO esperado para este bot√£o com base no seu √çNDICE
                    const fixedOutputId = fixedButtonOutputIds[index]; // 'output_2', 'Output_3', ou 'output_4'
                    const targetOutputElement = outputsContainer.querySelector(`.${fixedOutputId}`);
                    if (!targetOutputElement) {
                        console.warn(`[repositionButtonOutputs] Output ${fixedOutputId} n√£o encontrado para o bot√£o ${button.id}`);
                        return; // Skip this button if output not found
                    }

                    try {
                        // --- C√°lculo baseado em Offsets --- V2
                        // Objetivo: Alinhar o CENTRO VERTICAL do output com o CENTRO VERTICAL do bot√£o.

                        // 1. Centro vertical do bot√£o relativo ao topo do seu container (`buttonsContainer`)
                        //    offsetTop √© relativo ao offsetParent. Assumimos aqui que √© o suficiente
                        //    para comparar com a posi√ß√£o do output dentro do outputsContainer.
                        const buttonCenterYRelativeToItsContainer = buttonElement.offsetTop + (buttonElement.offsetHeight / 2);

                        // 2. Centro vertical do output relativo ao topo do seu container (`outputsContainer`)
                        // Precisamos que este centro coincida com o centro do bot√£o.
                        // A propriedade `style.top` define a posi√ß√£o do topo do output relativa ao topo do `outputsContainer`.
                        // Ent√£o: newTop + (outputElement.offsetHeight / 2) = buttonCenterYRelativeToItsContainer
                        // Logo: newTop = buttonCenterYRelativeToItsContainer - (outputElement.offsetHeight / 2)

                        // Obter a altura real do output (pode ser 0 se n√£o estiver vis√≠vel ainda)
                        const outputHeight = targetOutputElement.offsetHeight;
                        if (outputHeight === 0) {
                            console.warn(`[repositionButtonOutputs] Output ${fixedOutputId} tem offsetHeight 0. Pulando c√°lculo preciso. Verifique visibilidade/renderiza√ß√£o.`);
                            // Pode ser necess√°rio um fallback ou esperar renderiza√ß√£o completa.
                            // Tentar for√ßar um reflow pode ajudar em alguns casos, mas √© complexo.
                            // Ex: void targetOutputElement.offsetWidth; const outputHeight = targetOutputElement.offsetHeight;
                        } else {
                            let offsetY = 80;
                            if(index == 1) {
                                offsetY = 105;
                            }
                            if(index == 2) {
                                offsetY = 136;
                            }
                            const newTop = buttonCenterYRelativeToItsContainer - (outputHeight / 2) - offsetY;

                            // Aplica a nova posi√ß√£o (sem corre√ß√£o de zoom, pois usamos offsets)
                            targetOutputElement.style.top = `${newTop}px`;

                            // Garante que a posi√ß√£o seja relativa para o CSS funcionar corretamente
                            // O container (.outputs) precisa ter position: relative ou absolute
                            // E o item (.output) precisa ter position: absolute ou relative
                            // A biblioteca Drawflow geralmente define .output como absolute.
                            // Vamos garantir que o container .outputs seja relative se n√£o for.
                            if (window.getComputedStyle(outputsContainer).position === 'static') {
                                outputsContainer.style.position = 'relative';
                                console.warn(`[repositionButtonOutputs] Definindo position: relative para .outputs container do n√≥ ${nodeId}`);
                            }
                            // Garantir que o output seja absolute ou relative
                            if (window.getComputedStyle(targetOutputElement).position === 'static') {
                                targetOutputElement.style.position = 'absolute'; // Ou 'relative' - Absolute √© mais comum para .output em Drawflow
                                console.warn(`[repositionButtonOutputs] Definindo position: absolute para output ${fixedOutputId}`);
                            }


                            // Garante visibilidade
                            targetOutputElement.style.display = 'block';

                            console.log(`[repositionButtonOutputs V2] Posicionado output ${fixedOutputId} para bot√£o ${button.id} em top=${newTop}px (buttonOffsetTop=${buttonElement.offsetTop}, buttonH=${buttonElement.offsetHeight}, outputH=${outputHeight})`);
                        }
                        // --- Fim C√°lculo baseado em Offsets --- V2

                    } catch (error) {
                        console.error(`[repositionButtonOutputs] Erro ao calcular/aplicar posi√ß√£o para ${fixedOutputId}:`, error);
                    }
                });

                // Ocultar outputs n√£o utilizados (l√≥gica existente)
                fixedButtonOutputIds.forEach((outputId, index) => {
                    if (index >= replyButtons.length) {
                        const outputElement = outputsContainer.querySelector(`.${outputId}`);
                        if (outputElement) {
                            outputElement.style.display = 'none';
                            // console.log(`[repositionButtonOutputs] Ocultando output ${outputId} n√£o utilizado`);
                        }
                    }
                });
            } catch (error) {
                console.error(`[repositionButtonOutputs] Erro ao reposicionar outputs para o n√≥ ${nodeId}:`, error);
            }
        }


        // --- Handlers para Adicionar/Remover Bot√µes (Modificam tempNodeData) ---
        function addDynamicButtonHandler(nodeId) {
            const form = document.getElementById(`node-${nodeId}-form`); 
            if (!form) return;
            const buttonType = form.querySelector(`input[name="newButtonType_${nodeId}"]:checked`)?.value;
            const buttonTextInput = form.querySelector(`input[data-base-name="newButtonText"]`);
            const buttonUrlInput = form.querySelector(`input[data-base-name="newButtonUrl"]`);
            const buttonText = buttonTextInput?.value.trim();
            const buttonUrl = buttonUrlInput?.value.trim();

            if (!buttonType || !buttonText) { 
                Swal.fire('Aten√ß√£o', 'Selecione o tipo e digite o texto do bot√£o.', 'warning'); 
                return; 
            }
            if (buttonType === 'url' && !buttonUrl) { 
                Swal.fire('Aten√ß√£o', 'A URL √© obrigat√≥ria para bot√µes do tipo URL.', 'warning'); 
                return; 
            }
            if (buttonType === 'url') { 
                try { new URL(buttonUrl); } 
                catch (_) { 
                    Swal.fire('Aten√ß√£o', 'URL inv√°lida.', 'warning'); 
                    return; 
                } 
            }

            if (!tempNodeData.dynamicButtons) tempNodeData.dynamicButtons = [];
            if (tempNodeData.dynamicButtons.length >= 3) { 
                Swal.fire('Limite Atingido', 'M√°ximo de 3 bot√µes.', 'warning'); 
                return; 
            }

            const buttonId = generateUniqueId('btn');
            const newButton = { id: buttonId, text: buttonText, type: buttonType };
            
            // Mapeia para ID fixo ('output_2', 'output_3', 'output_4') se for bot√£o de resposta
            if (buttonType === 'reply') {
                // Calcula o √≠ndice do NOVO bot√£o de resposta entre os bot√µes de resposta existentes em tempNodeData
                const currentReplyButtonCount = tempNodeData.dynamicButtons.filter(b => b.type === 'reply').length;
                if (currentReplyButtonCount < fixedButtonOutputIds.length) {
                    // Associa o ID fixo correspondente ao √≠ndice (0 -> output_2, 1 -> output_3, 2 -> output_4)
                    newButton.outputId = fixedButtonOutputIds[currentReplyButtonCount];
                    console.log(`[Add Button] Bot√£o de resposta (ID: ${buttonId}) mapeado para output fixo: ${newButton.outputId}`);
                } else {
                    console.warn(`[Add Button] Limite de bot√µes de resposta (${fixedButtonOutputIds.length}) atingido. Novo bot√£o (ID: ${buttonId}) n√£o ter√° outputId mapeado.`);
                    // N√£o define outputId se o limite foi atingido
                }
            } else { // Bot√£o de URL
                newButton.url = buttonUrl;
                // Bot√µes de URL n√£o t√™m outputId
            }

            tempNodeData.dynamicButtons.push(newButton);
            console.log("Bot√£o adicionado (tempor√°rio):", newButton);

            // Limpa campos e atualiza lista no painel
            if (buttonTextInput) buttonTextInput.value = '';
            if (buttonUrlInput) buttonUrlInput.value = '';
            const replyRadio = form.querySelector(`input[name="newButtonType_${nodeId}"][value="reply"]`);
            if (replyRadio) replyRadio.checked = true;
            const urlDiv = document.getElementById(`newButtonUrlDiv_${nodeId}`);
            if (urlDiv) urlDiv.style.display = 'none';
            
            // Atualiza a lista visual de bot√µes no painel
            const listDiv = document.getElementById(`existing-buttons-${nodeId}`);
            if(listDiv) listDiv.appendChild(createButtonListItem(nodeId, newButton));
        }

        function removeDynamicButtonHandler(nodeId, buttonIdToRemove) {
            if (!tempNodeData || !tempNodeData.dynamicButtons) return;
            const buttonIndex = tempNodeData.dynamicButtons.findIndex(b => b.id === buttonIdToRemove);
            if (buttonIndex === -1) return;

            // Guarda os dados do bot√£o antes de remover do array principal
            const removedButton = { ...tempNodeData.dynamicButtons[buttonIndex] }; // Cria uma c√≥pia
            console.log("Bot√£o marcado para exclus√£o:", removedButton);

            // 1. Adiciona o bot√£o √† lista de marcados para exclus√£o (se ainda n√£o estiver)
            if (!tempNodeData.buttonsMarkedForDeletion) {
                tempNodeData.buttonsMarkedForDeletion = [];
            }
            if (!tempNodeData.buttonsMarkedForDeletion.some(b => b.id === buttonIdToRemove)) {
                tempNodeData.buttonsMarkedForDeletion.push(removedButton);
                console.log(`Bot√£o ${buttonIdToRemove} adicionado √† lista de exclus√£o.`);
            }

            // 2. Remove o bot√£o do array principal tempNodeData.dynamicButtons
            // Isso garante que ele n√£o ser√° inclu√≠do nos dados finais ao aplicar
            tempNodeData.dynamicButtons.splice(buttonIndex, 1);
            console.log(`Bot√£o ${buttonIdToRemove} removido de tempNodeData.dynamicButtons.`);

            // 3. Remove o item da lista visual no painel
            const listItem = document.querySelector(`#existing-buttons-${nodeId} .button-item[data-button-id="${buttonIdToRemove}"]`);
            if(listItem) {
                listItem.remove();
                console.log(`Item visual do bot√£o ${buttonIdToRemove} removido do painel.`);
            }

            // 4. N√ÉO removemos conex√µes ou outputs aqui. Isso ser√° feito em applyNodeChanges.
            console.log(`Exclus√£o de conex√µes/outputs para ${buttonIdToRemove} adiada para 'Aplicar Altera√ß√µes'.`);
        }

            
 
        // --- Fun√ß√µes Auxiliares de Cria√ß√£o de Campos ---
        function createInputField(labelText, name, value, type = 'text', allowVariables = false, nodeId = null) {
            const baseName = name; // Guarda o nome base
            const uniqueIdPart = nodeId ? `${baseName}-${nodeId}` : generateUniqueId('field');
            const id = `prop-${uniqueIdPart}`; // ID √∫nico para label e input
            const div = document.createElement('div'); div.className = 'form-group';
            const label = document.createElement('label'); label.textContent = labelText + ':'; label.htmlFor = id;
            const input = document.createElement('input'); input.type = type; input.id = id;
            // Usa ID √∫nico como nome para evitar conflitos no form, mas guarda nome base
            input.name = id;
            input.dataset.baseName = baseName;
            if (type !== 'file') input.value = value || '';
            input.className = 'form-control'; // Adiciona classe Bootstrap-like
            if (type === 'file') {
                // Define os tipos aceitos de forma mais expl√≠cita
                input.accept = "image/jpeg, image/png, image/gif, video/mp4, video/quicktime, audio/mpeg, audio/ogg, application/pdf, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation";
            }
            div.appendChild(label);
            const inputWrapper = document.createElement('div'); // Wrapper para input e √≠cone
            inputWrapper.style.position = 'relative'; // Necess√°rio para posicionar o √≠cone
            inputWrapper.appendChild(input);

            if (allowVariables) {
                const variableIcon = document.createElement('i');
                variableIcon.className = 'fas fa-tags variable-inserter-icon';
                variableIcon.title = 'Inserir Vari√°vel';
                variableIcon.style.position = 'absolute';
                variableIcon.style.right = '10px';
                variableIcon.style.top = '50%';
                variableIcon.style.transform = 'translateY(-50%)';
                variableIcon.style.cursor = 'pointer';
                variableIcon.style.color = '#007bff';
                variableIcon.onclick = (event) => {
                    event.stopPropagation(); // Evita que o clique feche um seletor j√° aberto
                    showVariableSelector(input);
                };
                inputWrapper.appendChild(variableIcon);
                // Adiciona a dica abaixo do campo
                const help = document.createElement('span');
                help.className = 'help-text';
                help.textContent = 'Use {{variavel}} ou clique no √≠cone.';
                div.appendChild(inputWrapper); // Adiciona o wrapper em vez do input direto
                div.appendChild(help);
            } else {
                div.appendChild(inputWrapper); // Adiciona o wrapper mesmo sem √≠cone para consist√™ncia
            }
            return div;
        }
        function createTextareaField(labelText, name, value, allowVariables = false, nodeId = null) {
            const baseName = name;
            const uniqueIdPart = nodeId ? `${baseName}-${nodeId}` : generateUniqueId('field');
            const id = `prop-${uniqueIdPart}`;
            const div = document.createElement('div'); div.className = 'form-group';
            const label = document.createElement('label'); label.textContent = labelText + ':'; label.htmlFor = id;
            const textarea = document.createElement('textarea'); textarea.id = id;
            textarea.name = id; textarea.dataset.baseName = baseName;
            textarea.value = value || ''; textarea.rows = 3; textarea.className = 'form-control';
            div.appendChild(label);
            const textareaWrapper = document.createElement('div');
            textareaWrapper.style.position = 'relative';
            textareaWrapper.appendChild(textarea);

            if (allowVariables) {
                const variableIcon = document.createElement('i');
                variableIcon.className = 'fas fa-tags variable-inserter-icon';
                variableIcon.title = 'Inserir Vari√°vel';
                variableIcon.style.position = 'absolute';
                variableIcon.style.right = '10px';
                variableIcon.style.top = '10px'; // Ajustado para textarea
                variableIcon.style.cursor = 'pointer';
                variableIcon.style.color = '#007bff';
                variableIcon.onclick = (event) => {
                    event.stopPropagation();
                    showVariableSelector(textarea);
                };
                textareaWrapper.appendChild(variableIcon);
                const help = document.createElement('span');
                help.className = 'help-text';
                help.textContent = 'Use {{variavel}} ou clique no √≠cone.';
                div.appendChild(textareaWrapper);
                div.appendChild(help);
            } else {
                div.appendChild(textareaWrapper);
            }
            return div;
        }
        function createSelectField(labelText, name, value, options, nodeId = null) {
            const baseName = name;
            const uniqueIdPart = nodeId ? `${baseName}-${nodeId}` : generateUniqueId('field');
            const id = `prop-${uniqueIdPart}`;
            const div = document.createElement('div'); div.className = 'form-group';
            const label = document.createElement('label'); label.textContent = labelText + ':'; label.htmlFor = id;
            const select = document.createElement('select'); select.id = id;
            select.name = id; select.dataset.baseName = baseName;
            select.className = 'form-control';
            options.forEach(opt => { const option = document.createElement('option'); option.value = opt.value; option.textContent = opt.text; if (opt.value === value) { option.selected = true; } select.appendChild(option); });
            div.appendChild(label); div.appendChild(select);
            return div;
        }


         // --- Nova Fun√ß√£o Auxiliar para Criar Select de Vari√°veis ---
        function createVariableSelectField(labelText, name, selectedValue, nodeId = null) {
             const baseName = name;
            const uniqueIdPart = nodeId ? `${baseName}-${nodeId}` : generateUniqueId('field');
             const id = `prop-${uniqueIdPart}`;
             const div = document.createElement('div'); div.className = 'form-group';
             const label = document.createElement('label'); label.textContent = labelText + ':'; label.htmlFor = id;
             const select = document.createElement('select'); select.id = id;
             select.name = id; select.dataset.baseName = baseName;
             select.className = 'form-control';

             // Preenche o select usando a fun√ß√£o existente
             populateVariableSelect(select, selectedValue);

             // Adiciona listener para atualizar tempNodeData
             select.addEventListener('change', handleFormChange);

             div.appendChild(label); div.appendChild(select);
           return div;
         }

        // --- Drag and Drop, Valida√ß√£o Conex√£o, Auxiliares (Export, Clear, Mode), Salvar Fluxo ---
        var elements = document.getElementsByClassName('drag-drawflow'); for (var i = 0; i < elements.length; i++) { elements[i].addEventListener('touchend', drop, false); elements[i].addEventListener('touchmove', positionMobile, false); elements[i].addEventListener('touchstart', drag, false ); } var mobile_item_selec = ''; var mobile_last_move = null; function positionMobile(ev) { mobile_last_move = ev; } function allowDrop(ev) { ev.preventDefault(); } function drag(ev) { if (ev.type === "touchstart") { mobile_item_selec = ev.target.closest(".drag-drawflow").getAttribute('data-node'); } else { ev.dataTransfer.setData("node", ev.target.getAttribute('data-node')); } } function drop(ev) { let nodeName, clientX, clientY; if (ev.type === "touchend") { if (!mobile_item_selec || !mobile_last_move) return; var parentdrawflow = document.elementFromPoint( mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY).closest("#drawflow"); if(parentdrawflow != null) { nodeName = mobile_item_selec; clientX = mobile_last_move.touches[0].clientX; clientY = mobile_last_move.touches[0].clientY; addNodeToDrawFlow(nodeName, clientX, clientY); } mobile_item_selec = ''; mobile_last_move = null; } else { ev.preventDefault(); nodeName = ev.dataTransfer.getData("node"); clientX = ev.clientX; clientY = ev.clientY; addNodeToDrawFlow(nodeName, clientX, clientY); } }
        editor.on('connectionCreated', function(connection) { console.log('Connection created:', connection); const outputNodeId = connection.output_id; const outputNode = editor.getNodeFromId(outputNodeId); if (outputNode && outputNode.name === 'inicio') { const outputConnections = editor.getNodeFromId(outputNodeId).outputs.output_1.connections; if (outputConnections.length > 1) { console.warn("N√≥ 'inicio' s√≥ pode ter uma conex√£o de sa√≠da."); editor.removeSingleConnection(connection.output_id, connection.input_id, connection.output_class, connection.input_class); Swal.fire('Aviso', 'O n√≥ "In√≠cio" s√≥ pode ter uma conex√£o de sa√≠da.', 'warning'); } } }); editor.on('connectionRemoved', function(connection) { console.log('Connection removed', connection); });
        function exportFlowData() { const exportedData = editor.export(); console.log(exportedData); const dataString = JSON.stringify(exportedData, null, 2); Swal.fire({ title: 'Dados Exportados (JSON)', html: `<pre><code style="text-align: left; display: block; white-space: pre-wrap;">${escapeHTML(dataString)}</code></pre>`, confirmButtonText: 'Fechar' }); } function clearFlow() { Swal.fire({ title: 'Limpar Fluxo?', text: "Remover todos os n√≥s e conex√µes?", icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', cancelButtonColor: '#3085d6', confirmButtonText: 'Sim, limpar!', cancelButtonText: 'Cancelar' }).then((result) => { if (result.isConfirmed) { editor.clearModuleSelected(); propertiesPanel.classList.remove('visible'); applyChangesButton.style.display = 'none'; selectedNodeId = null; tempNodeData = {}; Swal.fire('Limpo!', 'O fluxo foi limpo.', 'success'); } }); } function changeMode(option) { editor.editor_mode = option; const lockIcon = document.getElementById('lock'); const unlockIcon = document.getElementById('unlock'); if(option == 'fixed') { lockIcon.style.display = 'none'; unlockIcon.style.display = 'block'; propertiesPanel.classList.remove('visible'); applyChangesButton.style.display = 'none'; } else { lockIcon.style.display = 'block'; unlockIcon.style.display = 'none'; } }
        async function saveFlow() {
            Swal.fire({
                title: 'Aguarde...',
                text: 'Aguarde enquanto a requisi√ß√£o √© feita.',
                didOpen: () => { Swal.showLoading() },
                allowOutsideClick: false
            });
            const flowData = editor.export();
            console.log("flowData", flowData);
            const formData = new FormData();

            const title = flowTitleInput ? flowTitleInput.value : 'Novo Fluxo';
            const description = flowDescriptionInput ? flowDescriptionInput.value : '';
            console.log("title", title);
            formData.append('title', title);
            formData.append('description', description);
            // Serializa e adiciona as vari√°veis de usu√°rio (se existirem)
            if (window.userVariables && Array.isArray(window.userVariables)) {
                 formData.append('userVariables', JSON.stringify(window.userVariables));
            } else {
                 formData.append('userVariables', '[]'); // Envia array vazio se n√£o definido
            }


            // Processa n√≥s para anexar arquivos e adicionar flags
            const nodes = flowData.drawflow.Home.data;
            Object.keys(nodes).forEach(nodeId => {
                const node = nodes[nodeId];
                if (node.name === 'enviar_mensagem' && node.data) {
                    if (node.data._tempFile) { // Verifica se h√° um novo arquivo para upload
                        const fileKey = `file_node_${nodeId}`;
                        formData.append(fileKey, node.data._tempFile, node.data.mediaFileName); // Usa o nome original
                        node.data.has_uploaded_file = true; // Flag para backend
                        node.data.uploaded_file_key = fileKey; // Chave para backend
                        delete node.data._tempFile; // Remove objeto tempor√°rio do JSON final
                        // Mant√©m deleteMedia como false ou indefinido
                        delete node.data._deleteMedia;
                    } else if (node.data._deleteMedia === true) { // Verifica se a m√≠dia deve ser deletada
                        node.data.deleteMedia = true; // Flag para backend
                        // Garante que URL e nome sejam nulos no JSON enviado
                        node.data.mediaUrl = null;
                        node.data.mediaFileName = null;
                        delete node.data._deleteMedia; // Remove flag tempor√°ria
                        delete node.data._tempFile;
                    } else {
                        // Se n√£o houve mudan√ßa (nem upload nem delete), remove flags tempor√°rias
                        delete node.data._tempFile;
                        delete node.data._deleteMedia;
                    }
                }
            });

            // Adiciona o JSON do fluxo (agora com flags e sem arquivos tempor√°rios)
            formData.append('flow_json', JSON.stringify(flowData));
            console.log("formdata", formData);

            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
            const flowId = window.location.pathname.split('/').filter(Boolean).pop(); // Pega o ID da URL
            console.log("flowId", flowId);
            const isEditing = !isNaN(parseInt(flowId)) || (typeof flowId === 'string' && flowId.length > 5 && flowId !== 'drawflow') ; // Verifica se √© um ID v√°lido (int ou string UUID-like)

            let url = '/pt/api/flows/'; // URL para criar
            let method = 'POST';

            if (isEditing) {
                console.log("isEditing", isEditing);
                url = `/pt/api/flows/${flowId}/`; // URL para atualizar
                method = 'PATCH';
            } else {
                 console.warn("N√£o foi poss√≠vel determinar o ID do fluxo na URL para edi√ß√£o. Criando um novo fluxo.");
            }


            try {
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'X-CSRFToken': csrfToken
                        // N√£o defina 'Content-Type': 'multipart/form-data', o navegador faz isso automaticamente com FormData
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Erro ao salvar:', errorData);
                    Swal.fire('Erro!', `Falha ao salvar o fluxo: ${JSON.stringify(errorData)}`, 'error');
                    return; // Interrompe se houver erro
                }

                const result = await response.json();
                console.log('Salvo com sucesso:', result);
                Swal.fire('Salvo!', 'Fluxo salvo com sucesso.', 'success');

                // Se foi uma cria√ß√£o (POST) e o backend retornou o novo ID, atualiza a URL
                if (method === 'POST' && result.n8n_workflow_id) {
                    console.log("result", result);
                    const newUrl = `/flows/editor/${result.n8n_workflow_id}/`;
                    window.history.pushState({ path: newUrl }, '', newUrl);
                    console.log("URL atualizada para:", newUrl);
                } else if (isEditing) {
                     // Recarrega os dados do n√≥ ap√≥s salvar a edi√ß√£o para refletir a URL final da m√≠dia
                     // √â importante que o backend retorne o JSON atualizado completo
                     if (result.flow_json && typeof result.flow_json === 'object') {
                         // Atualiza a visualiza√ß√£o dos n√≥s de m√≠dia com as URLs retornadas
                         const updatedNodes = result.flow_json.drawflow.Home.data;
                         Object.keys(updatedNodes).forEach(nodeId => {
                            const nodeInfo = updatedNodes[nodeId];
                            if (nodeInfo.name === 'enviar_mensagem') {
                                // Atualiza o dado interno do Drawflow tamb√©m
                                editor.updateNodeDataFromId(nodeId, nodeInfo.data);
                                // Atualiza a visualiza√ß√£o
                                setTimeout(() => {
                                     updateMediaDisplay(nodeId, nodeInfo.data.mediaUrl, nodeInfo.data.mediaFileName);
                                     const nodeElement = document.getElementById(`node-${nodeId}`);;
                                     if (nodeElement) {
                                        const removeBtn = nodeElement.querySelector(`#remove-media-${nodeId}`);
                                        if(removeBtn) removeBtn.style.display = nodeInfo.data.mediaUrl ? 'inline-block' : 'none';
                                     }
                                }, 100); // Pequeno delay
                            }
                         });
                     }
                }

            } catch (error) {
                console.error('Erro na requisi√ß√£o:', error);
                Swal.fire('Erro!', 'Ocorreu um erro inesperado ao tentar salvar.', 'error');
            }
        }

        // --- Inicializa√ß√£o e Carregamento do Fluxo (se existente) ---
        document.addEventListener('DOMContentLoaded', async () => {
            loadVariables(); // Carrega vari√°veis do usu√°rio
            const flowId = flowIdInput.value;
        })
        // --- Listener para Zoom com Scroll Manual ---
        drawflowContainer.addEventListener('wheel', function(event) {
            // Verifica se o cursor est√° sobre o container principal do drawflow
            if (event.target.closest('#drawflow') === drawflowContainer) {
                event.preventDefault(); // Impede o scroll normal da p√°gina
                if (event.deltaY < 0) {
                    // Scroll para cima - Zoom In
                    editor.zoom_in();
                } else {
                    // Scroll para baixo - Zoom Out
                    editor.zoom_out();
                }
            }
        }, { passive: false }); // passive: false √© necess√°rio para preventDefault

        // Inicializa modo edi√ß√£o por padr√£o
        changeMode('edit');
 
        // --- Fun√ß√µes para Sele√ß√£o de Vari√°veis ---
        function showVariableSelector(targetInputElement) {
            // Remove seletor anterior, se existir
            if (variableSelectorElement) {
                variableSelectorElement.remove();
                variableSelectorElement = null;
            }

            variableSelectorElement = document.createElement('div');
            variableSelectorElement.className = 'variable-selector-dropdown';
            // Estilos b√°sicos (podem ser movidos para CSS)
            variableSelectorElement.style.position = 'absolute';
            variableSelectorElement.style.backgroundColor = 'white';
            variableSelectorElement.style.border = '1px solid #ccc';
            variableSelectorElement.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            variableSelectorElement.style.maxHeight = '200px';
            variableSelectorElement.style.overflowY = 'auto';
            variableSelectorElement.style.zIndex = '1050'; // Acima de outros elementos

            const inputRect = targetInputElement.getBoundingClientRect();
            variableSelectorElement.style.top = `${inputRect.bottom + window.scrollY}px`;
            variableSelectorElement.style.left = `${inputRect.left + window.scrollX}px`;
            variableSelectorElement.style.minWidth = `${inputRect.width}px`;

            const list = document.createElement('ul');
            list.style.listStyle = 'none';
            list.style.padding = '5px 0';
            list.style.margin = '0';

            // Combina vari√°veis pr√©-definidas e definidas pelo usu√°rio
            const allVariables = [...availableVariables, ...userDefinedVariables];

            // Agrupa por tipo (opcional, mas melhora a organiza√ß√£o)
            const groupedVariables = allVariables.reduce((acc, variable) => {
                let groupName = 'Pr√©-definidas';
                if (userDefinedVariables.some(uv => uv.name === variable.name)) {
                    groupName = 'Definidas pelo Usu√°rio';
                } else if (variable.name.startsWith('contato.')) {
                    groupName = 'Contato';
                } else if (variable.name.startsWith('sistema.')) {
                    groupName = 'Sistema';
                } else if (variable.name.startsWith('api_response.')) {
                    groupName = 'Resposta API';
                } else if (variable.name === 'user_response') {
                    groupName = 'Resposta Usu√°rio';
                }
                if (!acc[groupName]) acc[groupName] = [];
                acc[groupName].push(variable);
                return acc;
            }, {});

            // Ordena os grupos
            const groupOrder = ['Definidas pelo Usu√°rio', 'Contato', 'Resposta Usu√°rio', 'Resposta API', 'Sistema', 'Pr√©-definidas'];

            groupOrder.forEach(groupName => {
                if (groupedVariables[groupName]) {
                    // Adiciona um t√≠tulo para o grupo
                    const groupTitle = document.createElement('li');
                    groupTitle.style.padding = '5px 10px';
                    groupTitle.style.fontWeight = 'bold';
                    groupTitle.style.backgroundColor = '#eee';
                    groupTitle.style.marginTop = list.children.length > 0 ? '5px' : '0'; // Espa√ßo entre grupos
                    groupTitle.textContent = groupName;
                    list.appendChild(groupTitle);

                    // Adiciona vari√°veis do grupo
                    groupedVariables[groupName].sort((a, b) => a.name.localeCompare(b.name)).forEach(variable => {
                        const listItem = document.createElement('li');
                        listItem.style.padding = '5px 10px';
                        listItem.style.cursor = 'pointer';
                        // Mostra o tipo e descri√ß√£o
                        const typeInfo = variable.type ? ` <span style="color: #666; font-size: 0.8em;">(${variable.type})</span>` : '';
                        const description = variable.description ? `<br><small style="color: #555;">${escapeHTML(variable.description)}</small>` : '';
                        listItem.innerHTML = `<strong>${variable.name}</strong>${typeInfo}${description}`;
                        listItem.onmouseover = () => listItem.style.backgroundColor = '#f0f0f0';
                        listItem.onmouseout = () => listItem.style.backgroundColor = 'white';
                        listItem.onclick = () => {
                            insertVariable(targetInputElement, variable.name);
                            if (variableSelectorElement) variableSelectorElement.remove();
                            variableSelectorElement = null;
                        };
                        list.appendChild(listItem);
                    });
                }
            });

            variableSelectorElement.appendChild(list);
            document.body.appendChild(variableSelectorElement);

            // Adiciona listener para fechar ao clicar fora
            setTimeout(() => { // Timeout para evitar fechar imediatamente no clique do √≠cone
                document.addEventListener('click', closeVariableSelectorOnClickOutside, { once: true });
            }, 0);
        }

        function closeVariableSelectorOnClickOutside(event) {
            if (variableSelectorElement && !variableSelectorElement.contains(event.target) && !event.target.classList.contains('variable-inserter-icon')) {
                variableSelectorElement.remove();
                variableSelectorElement = null;
            } else if (variableSelectorElement) {
                // Se clicou dentro ou no √≠cone, re-adiciona o listener para o pr√≥ximo clique
                document.addEventListener('click', closeVariableSelectorOnClickOutside, { once: true });
            }
        }

        function insertVariable(targetInputElement, variableName) {
            const variableText = `${variableName}`;
            const start = targetInputElement.selectionStart;
            const end = targetInputElement.selectionEnd;
            const currentValue = targetInputElement.value;
            const newValue = currentValue.substring(0, start) + variableText + currentValue.substring(end);

            targetInputElement.value = newValue;

            // Atualiza tempNodeData (simula evento 'input')
            const event = new Event('input', { bubbles: true });
            targetInputElement.dispatchEvent(event);

            // Reposiciona o cursor ap√≥s a vari√°vel inserida
            targetInputElement.focus();
            targetInputElement.selectionStart = targetInputElement.selectionEnd = start + variableText.length;
        }

        // --- Fun√ß√£o para Teste de Chamada de API ---
        async function testApiCall(nodeId) {
            if (!selectedNodeId || selectedNodeId !== nodeId || !tempNodeData) {
                Swal.fire('Erro', 'Selecione o n√≥ de API e configure-o antes de testar.', 'error');
                return;
            }

            const { url, method, headers, body, responseVariable } = tempNodeData; // Inclui responseVariable
            const resultArea = document.getElementById(`api-test-result-${nodeId}`);
            const mappingArea = document.getElementById(`api-response-mapping-area-${nodeId}`);
            // Seleciona o <pre> diretamente pelo ID √∫nico
            const resultPre = document.getElementById(`api-test-result-content-${nodeId}`);
            if (!url || !method) {
                Swal.fire('Erro', 'URL e M√©todo HTTP s√£o obrigat√≥rios para testar.', 'error');
                return;
            }
            if (!resultArea || !resultPre || !mappingArea) {
                 console.error("Elementos da interface n√£o encontrados:", `Result Area: ${!!resultArea}`, `Result Pre: ${!!resultPre}`, `Mapping Area: ${!!mappingArea}`);
                 Swal.fire('Erro Interno', 'N√£o foi poss√≠vel encontrar os elementos da interface para o teste/mapeamento.', 'error');
                 return;
            }

            resultArea.style.display = 'block';
            mappingArea.style.display = 'none'; // Esconde mapeamento durante o teste
            resultPre.textContent = 'Testando...';
            Swal.fire({
                title: 'Testando API...',
                text: 'Aguarde enquanto a requisi√ß√£o √© feita.',
                didOpen: () => { Swal.showLoading() },
                allowOutsideClick: false
            });

            let parsedHeaders = {};
            try {
                parsedHeaders = headers ? JSON.parse(headers) : {};
                if (typeof parsedHeaders !== 'object' || parsedHeaders === null) throw new Error("Headers must be a JSON object.");
            } catch (e) {
                Swal.close();
                resultPre.textContent = `Erro ao processar Cabe√ßalhos (Headers):\n${e.message}\n\nVerifique se √© um JSON v√°lido. Ex: {"Content-Type": "application/json"}`;
                Swal.fire('Erro nos Cabe√ßalhos', 'Verifique o formato JSON dos cabe√ßalhos.', 'error');
                return;
            }

            let parsedBody = null;
            if (method !== 'GET' && method !== 'HEAD' && body) {
                try {
                    parsedBody = JSON.parse(body);
                    // N√£o precisa stringify aqui, fetch faz isso se Content-Type for json
                } catch (e) {
                    Swal.close();
                    resultPre.textContent = `Erro ao processar Corpo (Body):\n${e.message}\n\nVerifique se √© um JSON v√°lido.`;
                    Swal.fire('Erro no Corpo', 'Verifique o formato JSON do corpo da requisi√ß√£o.', 'error');
                    return;
                }
            }

            // Adiciona Content-Type se n√£o existir e o corpo for JSON
            if (parsedBody && !parsedHeaders['Content-Type'] && !parsedHeaders['content-type']) {
                parsedHeaders['Content-Type'] = 'application/json';
            }

            // Aviso sobre vari√°veis
            const hasVariables = (url + headers + body).includes('{{');
            if (hasVariables) {
                console.warn("Teste de API: Vari√°veis encontradas. Ser√£o enviadas literalmente.");
                // Poderia adicionar um aviso mais proeminente se desejado
            }

            try {
                const startTime = performance.now();
                const response = await fetch(url, {
                    method: method,
                    headers: parsedHeaders,
                    body: (parsedBody && method !== 'GET' && method !== 'HEAD') ? JSON.stringify(parsedBody) : undefined, // Stringify aqui
                    mode: 'cors' // Tenta CORS, pode falhar dependendo do servidor de destino
                });
                const endTime = performance.now();
                const duration = (endTime - startTime).toFixed(2);

                const responseBodyText = await response.text(); // L√™ como texto primeiro
                let responseBodyFormatted = responseBodyText;
                let responseHeaders = {};
                response.headers.forEach((value, key) => { responseHeaders[key] = value; });

                let jsonBody = null;
                let isJsonResponse = false;
                // Tenta formatar como JSON se for o caso
                try {
                    jsonBody = JSON.parse(responseBodyText);
                    responseBodyFormatted = JSON.stringify(jsonBody, null, 2);
                    isJsonResponse = true;
                } catch (e) { /* N√£o √© JSON, mant√©m como texto */ }

                const resultText = `--- Status: ${response.status} ${response.statusText} (${duration} ms) ---\n\n` +
                                   `--- Cabe√ßalhos da Resposta ---\n${JSON.stringify(responseHeaders, null, 2)}\n\n` +
                                   `--- Corpo da Resposta ---\n${responseBodyFormatted}`;

                resultPre.textContent = resultText;
                Swal.close();

                // Se a resposta foi OK e √© JSON, mostra e popula a √°rea de mapeamento
                if (response.ok && isJsonResponse && jsonBody && typeof jsonBody === 'object') {
                    mappingArea.style.display = 'block';
                    renderApiResponseMapping(nodeId, jsonBody, tempNodeData.responseMappings || []); // Passa resposta e mapeamentos atuais
                    Swal.fire('Teste Conclu√≠do', `Status: ${response.status}. Configure o mapeamento abaixo.`, 'success');
                } else if (response.ok) {
                    mappingArea.style.display = 'none'; // Esconde se n√£o for JSON
                    Swal.fire('Teste Conclu√≠do', `Status: ${response.status}. Resposta n√£o √© JSON, mapeamento n√£o dispon√≠vel.`, 'success');
                } else {
                    mappingArea.style.display = 'none'; // Esconde em caso de erro
                    Swal.fire('Teste Conclu√≠do com Erro', `Status: ${response.status}`, 'warning');
                }
            } catch (error) {
                const endTime = performance.now();
                // const duration = (endTime - startTime).toFixed(2); // startTime n√£o definido aqui
                console.error("Erro no Teste de API:", error);
                Swal.close();
                let errorDetails = `Erro: ${error.message}\n\n`;
                if (error.cause) {
                    errorDetails += `Causa: ${error.cause}\n\n`;
                }
                errorDetails += `Verifique a URL, a configura√ß√£o de CORS no servidor de destino ou a conectividade de rede.`;
                resultPre.textContent = errorDetails;
                Swal.fire('Erro no Teste', 'N√£o foi poss√≠vel completar a requisi√ß√£o.', 'error');
                mappingArea.style.display = 'none'; // Esconde mapeamento em caso de erro de fetch
            }
        }

        // --- Fun√ß√µes para Mapeamento de Resposta da API ---

        // Renderiza as linhas de mapeamento com base na resposta da API e mapeamentos existentes
        function renderApiResponseMapping(nodeId, jsonResponse, existingMappings = []) {
            const container = document.getElementById(`mapping-rows-container-${nodeId}`);
            if (!container) return;
            container.innerHTML = ''; // Limpa linhas anteriores

            let apiFields = [];
            if (jsonResponse && typeof jsonResponse === 'object') {
                // Extrai chaves do primeiro n√≠vel (como na imagem)
                apiFields = Object.keys(jsonResponse);
                // Poderia ser estendido para extrair chaves aninhadas recursivamente se necess√°rio
                // Ex: function extractKeys(obj, prefix = '') { ... }
            }

            // Combina campos da API com mapeamentos existentes (para preservar mapeamentos manuais)
            // Garante que os campos da API venham primeiro, depois os manuais n√£o encontrados na API
            const existingManualFields = existingMappings.filter(m => !apiFields.includes(m.apiField)).map(m => m.apiField);
            const allMappingFields = [...apiFields, ...existingManualFields];

            allMappingFields.forEach((field, index) => {
                // Pula campos vazios que n√£o est√£o em mapeamentos existentes (redundante com a l√≥gica acima, mas seguro)
                if (!field && !existingMappings.some(m => m.apiField === field)) return;

                const existingMap = existingMappings.find(m => m.apiField === field);
                const localVariable = existingMap ? existingMap.localVariable : '';
                container.appendChild(createMappingRow(nodeId, index, field, localVariable));
            });

            // Atualiza tempNodeData com os mapeamentos renderizados (importante para manter consist√™ncia)
            updateMappingsFromDOM(nodeId);
        }

        // Cria uma √∫nica linha de mapeamento (API Field -> Local Variable)
        function createMappingRow(nodeId, index, apiFieldValue = '', localVariableValue = '') {
            const row = document.createElement('div');
            row.className = 'mapping-row';
            row.dataset.index = index; // Adiciona √≠ndice para refer√™ncia

            // Input para o campo da API (pode ser edit√°vel para mapeamento manual)
            const apiFieldInput = document.createElement('input');
            apiFieldInput.type = 'text';
            apiFieldInput.className = 'form-control api-field-input';
            apiFieldInput.placeholder = "$.campo.api ou nome"; // Exemplo de formato
            apiFieldInput.value = apiFieldValue;
            apiFieldInput.name = `map-api-field`; // Nome base para handleFormChange
            apiFieldInput.dataset.index = index; // √çndice para handleFormChange
            apiFieldInput.oninput = () => handleFormChange({ target: apiFieldInput }); // Atualiza temp data

            // Select para a vari√°vel local
            const localVariableSelect = document.createElement('select');
            localVariableSelect.className = 'form-control local-variable-select';
            localVariableSelect.name = `map-local-variable`; // Nome base para handleFormChange
            localVariableSelect.dataset.index = index; // √çndice para handleFormChange
            localVariableSelect.onchange = () => handleFormChange({ target: localVariableSelect }); // Atualiza temp data
            populateVariableSelect(localVariableSelect, localVariableValue); // Preenche com vari√°veis dispon√≠veis

            // Bot√£o para remover a linha
            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.className = 'control-button remove-mapping-row';
            removeButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
            removeButton.title = 'Remover Mapeamento';
            removeButton.onclick = () => removeMappingRow(nodeId, index);

            row.appendChild(apiFieldInput);
            row.appendChild(localVariableSelect);
            row.appendChild(removeButton);

            return row;
        }

        // Adiciona uma linha de mapeamento vazia (manual)
        function addManualMappingRow(nodeId) {
            const container = document.getElementById(`mapping-rows-container-${nodeId}`);
            if (!container) return;
            const newIndex = container.children.length;
            container.appendChild(createMappingRow(nodeId, newIndex, '', ''));
            // Atualiza tempNodeData para incluir a nova linha vazia
            updateMappingsFromDOM(nodeId);
        }

        // Remove uma linha de mapeamento pelo √≠ndice
        function removeMappingRow(nodeId, indexToRemove) {
            const container = document.getElementById(`mapping-rows-container-${nodeId}`);
            if (!container) return;
            const rowToRemove = container.querySelector(`.mapping-row[data-index="${indexToRemove}"]`);
            if (rowToRemove) {
                rowToRemove.remove();
                // Reindexa as linhas restantes e atualiza tempNodeData
                const remainingRows = container.querySelectorAll('.mapping-row');
                remainingRows.forEach((row, newIndex) => {
                    row.dataset.index = newIndex;
                    // Atualiza dataset.index nos inputs/selects tamb√©m
                    row.querySelectorAll('input, select').forEach(el => el.dataset.index = newIndex);
                });
                updateMappingsFromDOM(nodeId); // Atualiza tempNodeData ap√≥s remover e reindexar
            }
        }

        // Atualiza tempNodeData.responseMappings com base no estado atual do DOM
        function updateMappingsFromDOM(nodeId) {
            const container = document.getElementById(`mapping-rows-container-${nodeId}`);
            if (!container || !tempNodeData) return;

            const rows = container.querySelectorAll('.mapping-row');
            const newMappings = [];
            rows.forEach(row => {
                const apiField = row.querySelector('.api-field-input')?.value || '';
                const localVariable = row.querySelector('.local-variable-select')?.value || '';
                // S√≥ adiciona se pelo menos um dos campos estiver preenchido
                if (apiField || localVariable) {
                    newMappings.push({ apiField, localVariable });
                }
            });
            tempNodeData.responseMappings = newMappings;
            console.log("Temp mappings updated from DOM:", tempNodeData.responseMappings);
        }

        // Preenche um elemento select com as vari√°veis dispon√≠veis
        function populateVariableSelect(selectElement, selectedValue = '') {
            if (!selectElement) return;
            selectElement.innerHTML = ''; // Limpa op√ß√µes existentes

            // Op√ß√£o padr√£o
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '-- Selecione ou Crie --';
            selectElement.appendChild(defaultOption);

            // Combina vari√°veis pr√©-definidas e definidas pelo usu√°rio
            const allVariables = [...availableVariables, ...userDefinedVariables];

            // Agrupa (opcional, mas melhora UX)
            const groupedVariables = allVariables.reduce((acc, variable) => {
                let groupName = 'Outras';
                if (userDefinedVariables.some(uv => uv.name === variable.name)) groupName = 'Definidas pelo Usu√°rio';
                else if (variable.name.startsWith('contato.')) groupName = 'Contato';
                else if (variable.name.startsWith('sistema.')) groupName = 'Sistema';
                else if (variable.name.startsWith('api_response.')) groupName = 'Resposta API (Geral)';
                else if (variable.name === 'user_response') groupName = 'Resposta Usu√°rio';

                if (!acc[groupName]) acc[groupName] = [];
                acc[groupName].push(variable);
                return acc;
            }, {});

            const groupOrder = ['Definidas pelo Usu√°rio', 'Contato', 'Resposta Usu√°rio', 'Resposta API (Geral)', 'Sistema', 'Outras'];

            groupOrder.forEach(groupName => {
                if (groupedVariables[groupName]) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = groupName;
                    groupedVariables[groupName].sort((a, b) => a.name.localeCompare(b.name)).forEach(variable => {
                        const option = document.createElement('option');
                        option.value = variable.name;
                        // Mostra tipo se for definida pelo usu√°rio
                        const typeSuffix = variable.type ? ` (${variable.type})` : '';
                        option.textContent = variable.name + typeSuffix;
                        if (variable.name === selectedValue) {
                            option.selected = true;
                        }
                        optgroup.appendChild(option);
                    });
                    selectElement.appendChild(optgroup);
                }
            });
 
            // Ensure the provided selectedValue is actually selected
            if (selectedValue && selectElement.querySelector(`option[value="${selectedValue}"]`)) {
                 selectElement.value = selectedValue;
            } else if (selectedValue) {
                 console.warn(`[populateVariableSelect] Valor selecionado '${selectedValue}' n√£o encontrado nas op√ß√µes.`);
            }
        }
 
        // --- Fun√ß√£o para atualizar TODOS os selects de vari√°veis na UI ---
        function refreshAllVariableSelects(newlySelectedValue = null) {
            console.log("[Refresh Selects] Atualizando todos os selects de vari√°veis...");
            // Atualiza selects no painel de propriedades (se aberto)
            if (selectedNodeId) {
                const propertiesForm = document.getElementById(`node-${selectedNodeId}-form`);
                if (propertiesForm) {
                    const selects = propertiesForm.querySelectorAll('select.local-variable-select, select[data-base-name="variableName"]'); // Inclui o select do 'Aguardar Resposta'
                    selects.forEach(select => {
                        const currentValue = select.value;
                        // Se um novo valor foi selecionado (ex: ap√≥s criar vari√°vel), usa ele, sen√£o mant√©m o atual
                        const valueToSelect = (newlySelectedValue && select.dataset.baseName === 'localVariable') ? newlySelectedValue : currentValue;
                        populateVariableSelect(select, valueToSelect);
                    });
                    console.log(`[Refresh Selects] Selects atualizados no painel para n√≥ ${selectedNodeId}.`);
                }
            }
            // Poderia adicionar l√≥gica para atualizar selects em outros lugares se necess√°rio
        }
 
        // --- Modal para Criar Vari√°vel Rapidamente ---
        // Modificado para n√£o receber targetSelectElement, pois atualiza todos os selects
        function showCreateVariableModal(nodeId) {
            Swal.fire({
                title: 'Criar Nova Vari√°vel Local',
                html: `
                    <input id="swal-input-var-name" class="swal2-input" placeholder="Nome da vari√°vel (ex: cliente_id)">
                    <select id="swal-select-var-type" class="swal2-select" style="display: block; width: 80%; margin: 1em auto;">
                        <option value="string" selected>Texto (String)</option>
                        <option value="number">N√∫mero (Number)</option>
                        <option value="boolean">Booleano (Boolean)</option>
                        <option value="date">Data/Hora (Date)</option>
                        <option value="list">Lista (List/Array)</option>
                        <option value="object">Objeto (Object/Dict)</option>
                    </select>
                    <input id="swal-input-var-desc" class="swal2-input" placeholder="Descri√ß√£o (opcional)">
                `,
                confirmButtonText: 'Criar Vari√°vel',
                focusConfirm: false,
                preConfirm: () => {
                    const nameInput = Swal.getPopup().querySelector('#swal-input-var-name');
                    const typeSelect = Swal.getPopup().querySelector('#swal-select-var-type');
                    const descInput = Swal.getPopup().querySelector('#swal-input-var-desc');
                    const name = nameInput.value.trim();
                    const type = typeSelect.value;
                    const description = descInput.value.trim();
                    if (!name) {
                        Swal.showValidationMessage(`Por favor, insira um nome para a vari√°vel.`);
                        return false;
                    }
                    // Valida√ß√£o simples do nome (evitar espa√ßos, caracteres especiais, etc.)
                    if (!/^[a-zA-Z0-9_.]+$/.test(name)) { // Permite pontos agora
                        Swal.showValidationMessage(`Nome inv√°lido. Use letras, n√∫meros, underscore (_) ou ponto (.).`);
                        return false;
                    }
                    if (availableVariables.some(v => v.name === name) || userDefinedVariables.some(v => v.name === name)) {
                        Swal.showValidationMessage(`Vari√°vel "${name}" j√° existe.`);
                        return false;
                    }
                    return { name: name, type: type, description: description };
                }
            }).then((result) => {
                if (result.isConfirmed && result.value) {
                    const { name, type, description } = result.value;
                    updateUserDefinedVariables(name, type, description); // Adiciona √† lista global

                    // Atualiza todos os selects de vari√°veis na se√ß√£o de mapeamento atual
                    const mappingContainer = document.getElementById(`mapping-rows-container-${nodeId}`);
                    if (mappingContainer) {
                        const selects = mappingContainer.querySelectorAll('.local-variable-select');
                        selects.forEach(select => {
                            const currentValue = select.value; // Salva valor atual
                            populateVariableSelect(select, currentValue === '' ? name : currentValue); // Repopula, selecionando a nova se nada estiver selecionado
                        });
                    }

                    // Atualiza tamb√©m o seletor de vari√°veis global, se estiver aberto
                    if (variableSelectorElement) {
                        // Reabre o seletor para refletir a nova vari√°vel
                        const currentTarget = variableSelectorElement.dataset.targetInputId ? document.getElementById(variableSelectorElement.dataset.targetInputId) : null;
                        variableSelectorElement.remove();
                        variableSelectorElement = null;
                        if (currentTarget) {
                            // Adiciona ID ao input temporariamente se n√£o tiver
                            const hadId = !!currentTarget.id;
                            if (!hadId) currentTarget.id = generateUniqueId('tempInput');
                            variableSelectorElement.dataset.targetInputId = currentTarget.id; // Guarda ID do input alvo
                            showVariableSelector(currentTarget);
                            if (!hadId) currentTarget.removeAttribute('id'); // Remove ID tempor√°rio
                        }
                    }

                    Swal.fire('Criada!', `Vari√°vel "${name}" (${type}) criada com sucesso.`, 'success');
                }
            });
        }

        // Evento ao mudar o n√≥ atual
        editor.on('node:selected', function(nodeId) {
            currentSelectedNodeId = nodeId;
            
            // Atualizar reposit√≥rios para o n√≥ selecionado
            if (nodeId) {
                setTimeout(() => {
                    repositionButtonOutputs(nodeId);
                }, 300); // Atraso para garantir que o DOM est√° atualizado
            }
        });

        // Evento ao adicionar um n√≥ (via importa√ß√£o ou UI)
        editor.on('nodeCreated', function(nodeId) {
            // Verificar se √© um n√≥ de enviar mensagem e se tem bot√µes
            const node = editor.getNodeFromId(nodeId);
            if (node && node.name === 'enviar_mensagem') {
                setTimeout(() => {
                    repositionButtonOutputs(nodeId);
                }, 500); // Atraso maior para n√≥s rec√©m-criados
            }
        });

        // Sempre que uma conex√£o √© criada
        editor.on('connectionCreated', function(connection) {
            // Encontrar o n√≥ de origem da conex√£o
            const sourceNodeId = connection.output_id.split('-')[0];
            if (sourceNodeId) {
                setTimeout(() => {
                    repositionButtonOutputs(sourceNodeId);
                }, 200);
            }
        });

        // Ap√≥s a importa√ß√£o de fluxo
        editor.on('import', function() {
            console.log('[Editor] Fluxo importado, ajustando posi√ß√µes dos outputs...');
            // Para cada n√≥ do tipo "enviar_mensagem"
            setTimeout(() => {
                const nodeIds = Object.keys(editor.drawflow.drawflow.Home.data);
                nodeIds.forEach(nodeId => {
                    const node = editor.getNodeFromId(nodeId);
                    if (node && node.name === 'enviar_mensagem') {
                        setTimeout(() => {
                            repositionButtonOutputs(nodeId);
                        }, 100 * parseInt(nodeId)); // Escalonar ajustes para evitar sobrecarga
                    }
                });
            }, 1000); // Atraso maior ap√≥s importa√ß√£o
        });

        // Listener para o evento node:selected - reposicionar bot√µes ap√≥s sele√ß√£o de n√≥
        editor.on('nodeSelected', function(id) {
            setTimeout(() => {
                if (editor.getNodeFromId(id)?.name === 'enviar_mensagem') {
                    repositionButtonOutputs(id);
                }
            }, 300);
        });

        // Listener para o evento nodeCreated - reposicionar bot√µes ap√≥s cria√ß√£o de n√≥
        editor.on('nodeCreated', function(id) {
            setTimeout(() => {
                if (editor.getNodeFromId(id)?.name === 'enviar_mensagem') {
                    repositionButtonOutputs(id);
                }
            }, 500);
        });

        // Listener para o evento connectionCreated - reposicionar bot√µes ap√≥s cria√ß√£o de conex√£o
        editor.on('connectionCreated', function(connection) {
            if (connection && connection.output_id) {
                setTimeout(() => {
                    repositionButtonOutputs(connection.output_id);
                }, 200);
            }
        });

        // Listener para o evento import - reposicionar bot√µes ap√≥s importa√ß√£o de fluxo
        editor.on('import', function(flowData) {
            console.log("Fluxo importado, reposicionando bot√µes...");
            setTimeout(() => {
                const nodes = editor.export().drawflow.Home.data;
                for (const nodeId in nodes) {
                    const node = nodes[nodeId];
                    if (node.name === 'enviar_mensagem') {
                        setTimeout(() => {
                            repositionButtonOutputs(nodeId);
                        }, parseInt(nodeId) * 50); // Adiciona um atraso escalonado baseado no ID do n√≥
                    }
                }
            }, 1000);
        });

        // Fun√ß√£o para reposicionar as sa√≠das dos n√≥s de condi√ß√£o
        function repositionConditionOutputs(nodeId) {
            try {
                if (!nodeId) {
                    console.warn(`[repositionConditionOutputs] Chamada sem nodeId definido`);
                    return;
                }

                // Buscar elementos no DOM
                const nodeElement = document.querySelector(`#node-${nodeId}`);
                if (!nodeElement) {
                    console.warn(`[repositionConditionOutputs] N√≥ #node-${nodeId} n√£o encontrado no DOM`);
                    return;
                }

                // Pega os dados mais recentes do n√≥
                const nodeInternals = editor.getNodeFromId(nodeId); // Pega o n√≥ interno para verificar o tipo

                if (!nodeInternals || nodeInternals.name !== 'condicao') {
                    // N√£o √© um n√≥ de condi√ß√£o, ignorando
                    return;
                }

                const outputsContainer = nodeElement.querySelector('.outputs');
                if (!outputsContainer) {
                    console.warn(`[repositionConditionOutputs] Container de sa√≠das n√£o encontrado no n√≥ ${nodeId}.`);
                    return;
                }

                // Encontra os elementos de sa√≠da usando as classes output_1 e output_2
                // que s√£o os padr√µes do Drawflow
                const trueOutputElement = outputsContainer.querySelector('.output_1');
                const falseOutputElement = outputsContainer.querySelector('.output_2');

                if (!trueOutputElement || !falseOutputElement) {
                    console.warn(`[repositionConditionOutputs] Outputs output_1/output_2 n√£o encontrados no n√≥ ${nodeId}.`);
                    return;
                }

                // Ajustando posi√ß√µes manualmente para garantir alinhamento com os r√≥tulos
                trueOutputElement.style.top = '110px';  // Alinhado com o r√≥tulo True
                falseOutputElement.style.top = '140px'; // Alinhado com o r√≥tulo False
                trueOutputElement.style.right = '-10px'; // Ajusta a posi√ß√£o horizontal
                falseOutputElement.style.right = '-10px'; // Ajusta a posi√ß√£o horizontal

                console.log(`[repositionConditionOutputs] Outputs do n√≥ de condi√ß√£o ${nodeId} reposicionados.`);
            } catch (error) {
                console.error(`[repositionConditionOutputs] Erro ao reposicionar outputs do n√≥ ${nodeId}:`, error);
            }
        }

        // Modificar a fun√ß√£o de evento 'nodeCreated' para chamar repositionConditionOutputs quando n√≥s de condi√ß√£o forem criados
        editor.on('nodeCreated', function(nodeId) {
            // ... existing code ...
            
            // Verificar se √© um n√≥ de condi√ß√£o e reposicionar os outputs
            const node = editor.getNodeFromId(nodeId);
            if (node && node.name === 'condicao') {
                // Adicionar um pequeno atraso para garantir que o DOM esteja atualizado
                setTimeout(() => {
                    repositionConditionOutputs(nodeId);
                }, 100);
            }
        });

        // Adicionar tamb√©m ao evento de importa√ß√£o para reposicionar outputs dos n√≥s de condi√ß√£o ap√≥s importar um fluxo
        editor.on('import', function(flowData) {
            console.log("Fluxo importado, reposicionando bot√µes e outputs de condi√ß√£o...");
            setTimeout(() => {
                const nodes = editor.export().drawflow.Home.data;
                for (const nodeId in nodes) {
                    const node = nodes[nodeId];
                    if (node.name === 'enviar_mensagem') {
                        setTimeout(() => {
                            repositionButtonOutputs(nodeId);
                        }, parseInt(nodeId) * 50); // Adiciona um atraso escalonado baseado no ID do n√≥
                    } else if (node.name === 'condicao') {
                        setTimeout(() => {
                            repositionConditionOutputs(nodeId);
                        }, parseInt(nodeId) * 50); // Atraso escalonado similar
                    }
                }
            }, 1000);
        });

        // Listener para o evento nodeDataChanged para reposicionar outputs de condi√ß√£o
        editor.on('nodeDataChanged', function(nodeId) {
            // Verifica se √© um n√≥ de condi√ß√£o
            const node = editor.getNodeFromId(nodeId);
            if (node && node.name === 'condicao') {
                // Adicionar um pequeno atraso para garantir que o DOM esteja atualizado
                setTimeout(() => {
                    repositionConditionOutputs(nodeId);
                }, 100);
            }
        });

        // Adiciona listener para redimensionamento da janela para ajustar posi√ß√µes de outputs
        window.addEventListener('resize', function() {
            // Obt√©m todos os n√≥s de condi√ß√£o e reposiciona seus outputs
            const nodes = editor.export().drawflow.Home.data;
            for (const nodeId in nodes) {
                const node = nodes[nodeId];
                if (node.name === 'condicao') {
                    repositionConditionOutputs(nodeId);
                }
            }
        });

        // --- Event Listener para Atualizar Posi√ß√µes no Zoom ---
        editor.on('zoom', function(zoomLevel) {
            // console.log('[Zoom Event] Zoom alterado para:', zoomLevel);
            // Reposiciona outputs de bot√µes para todos os n√≥s de mensagem vis√≠veis
            const nodes = editor.export().drawflow[editor.module].data;
            for (const nodeId in nodes) {
                const node = nodes[nodeId];
                if (node.name === 'enviar_mensagem') {
                    // Chama a fun√ß√£o de reposicionamento para cada n√≥ de mensagem
                    // Adiciona um pequeno delay para evitar sobrecarga em zooms r√°pidos
                    // setTimeout(() => {
                         repositionButtonOutputs(nodeId);
                    // }, 50); // Ajuste o delay conforme necess√°rio
                }
                // Poderia adicionar reposicionamento de condi√ß√£o aqui tamb√©m se necess√°rio
                 else if (node.name === 'condicao') {
                     // setTimeout(() => {
                          repositionConditionOutputs(nodeId);
                     // }, 50);
                 }
            }
        });

        // --- Handler para Excluir Arquivo Anexado (no painel) ---
        function deleteUploadedFileHandler(nodeId) {
            if (!selectedNodeId || selectedNodeId !== nodeId || !tempNodeData) return;

            const fileInput = document.querySelector(`input[data-base-name="mediaFile"][id^="prop-${nodeId}"]`);
            const previewProp = document.getElementById(`media-preview-prop-${nodeId}`);
            const deleteBtn = document.getElementById(`delete-media-button-${nodeId}`);

            console.log(`[Delete Media Handler ${nodeId}] Iniciando exclus√£o.`);

            // Limpa o input file
            if (fileInput) fileInput.value = null;
            // Limpa o preview
            if (previewProp) previewProp.innerHTML = '';
            // Esconde o bot√£o delete
            if (deleteBtn) deleteBtn.style.display = 'none';

            // Limpa dados tempor√°rios relacionados ao arquivo local
            delete tempNodeData.mediaFile;
            delete tempNodeData.mediaPreviewUrl;
            delete tempNodeData.mediaFileName;
            delete tempNodeData.mediaFileType;

            // Verifica se existia uma URL (m√≠dia previamente salva)
            const existingMediaUrl = tempNodeData.mediaUrl;
            if (existingMediaUrl) {
                console.log(`[Delete Media Handler ${nodeId}] Marcando m√≠dia existente (${existingMediaUrl}) para exclus√£o.`);
                tempNodeData.deleteMedia = true; // Marca para exclus√£o no backend
                tempNodeData.mediaUrl = ''; // Limpa a URL dos dados tempor√°rios
                // Limpa o campo de input da URL no painel tamb√©m
                const urlInput = document.querySelector(`input[data-base-name="mediaUrl"][id^="prop-${nodeId}"]`);
                if (urlInput) urlInput.value = '';
            } else {
                // Se n√£o havia URL, garante que deleteMedia seja false
                tempNodeData.deleteMedia = false;
            }

            console.log(`[Delete Media Handler ${nodeId}] Dados tempor√°rios ap√≥s exclus√£o:`, JSON.parse(JSON.stringify(tempNodeData)));
            Swal.fire({
                icon: 'info',
                title: 'Arquivo Removido',
                text: 'O arquivo anexado foi removido. Clique em "Aplicar Altera√ß√µes" para confirmar.',
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000
            });
        }

        // Fun√ß√£o para obter o token CSRF do cookie
        function getCsrfToken() {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, 'csrftoken'.length + 1) === ('csrftoken' + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring('csrftoken'.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Fun√ß√£o para atualizar/adicionar vari√°veis definidas pelo usu√°rio
        function updateUserDefinedVariables(name, type, description) {
            // Valida os par√¢metros
            if (!name || typeof name !== 'string') {
                console.warn('updateUserDefinedVariables: Nome inv√°lido ou ausente', name);
                return; // N√£o adiciona se n√£o houver nome v√°lido
            }
            
            // Procura se a vari√°vel j√° existe para atualizar
            const index = userDefinedVariables.findIndex(v => v.name === name);
            
            if (index >= 0) {
                // Atualiza a vari√°vel existente
                userDefinedVariables[index] = {
                    name,
                    type: type || 'string', // Padr√£o: string
                    description: description || ''
                };
            } else {
                // Adiciona nova vari√°vel
                userDefinedVariables.push({
                    name,
                    type: type || 'string', // Padr√£o: string
                    description: description || ''
                });
            }
            
            // Opcional: Atualiza qualquer interface baseada nessa lista
            console.log(`Vari√°vel ${name} ${index >= 0 ? 'atualizada' : 'adicionada'} (${type}): ${description}`);
        }

        // Fun√ß√£o para carregar vari√°veis do sistema e pr√©-definidas
        function loadVariables() {
            console.log("Carregando vari√°veis dispon√≠veis e pr√©-definidas...");
            
            // Se as vari√°veis j√° estiverem carregadas, n√£o faz nada
            if (availableVariables && availableVariables.length > 0) {
                console.log("Vari√°veis j√° carregadas. Total:", availableVariables.length);
                return;
            }
            
            try {
                // Aqui voc√™ poderia fazer uma chamada API para buscar vari√°veis do backend
                // Por enquanto, vamos usar as vari√°veis que j√° est√£o definidas no availableVariables
                
                console.log("Vari√°veis do sistema carregadas com sucesso. Total:", availableVariables.length);
                
                // Voc√™ tamb√©m pode carregar vari√°veis definidas pelo usu√°rio de algum armazenamento
                // Por exemplo, se elas estiverem salvas no localStorage:
                const savedUserVars = localStorage.getItem('userDefinedVariables');
                if (savedUserVars) {
                    try {
                        const parsedVars = JSON.parse(savedUserVars);
                        if (Array.isArray(parsedVars)) {
                            userDefinedVariables = parsedVars;
                            console.log("Vari√°veis do usu√°rio carregadas do armazenamento local. Total:", userDefinedVariables.length);
                        }
                    } catch (e) {
                        console.error("Erro ao carregar vari√°veis do usu√°rio do armazenamento:", e);
                    }
                }
            } catch (error) {
                console.error("Erro ao carregar vari√°veis:", error);
            }
        }

        // Substitua o c√≥digo atual que usa FileReader
        function handleFileSelect(nodeId, event) {
            const fileInput = event.target;
            const file = fileInput.files[0];
            if (!file) return;
            
            console.log(`Processando arquivo selecionado: ${file.name}, tipo: ${file.type}`);
            
            if (!tempNodeData[nodeId]) {
                tempNodeData[nodeId] = {};
            }
            
            // Configura o preview local
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    // Este preview √© apenas para o editor (n√£o vai para o backend)
                    tempNodeData[nodeId].mediaPreviewUrl = e.target.result;
                    
                    // Armazena a refer√™ncia ao arquivo para upload posterior
                    tempNodeData[nodeId].mediaFile = file;
                    tempNodeData[nodeId].mediaFileName = file.name;
                    tempNodeData[nodeId].mediaFileType = file.type;
                    
                    // Atualiza o visual do n√≥
                    updateNodeVisual(nodeId);
                    applyChangesButton.style.display = 'block';
                };
                reader.readAsDataURL(file);
            } else {
                // Para outros tipos de arquivo (sem preview de imagem)
                tempNodeData[nodeId].mediaFile = file;
                tempNodeData[nodeId].mediaFileName = file.name;
                tempNodeData[nodeId].mediaFileType = file.type;
                
                // Atualiza o visual
                updateNodeVisual(nodeId);
                applyChangesButton.style.display = 'block';
            }
            
            console.log(`Arquivo configurado para n√≥ ${nodeId}: ${file.name}`);
        }

        // Encontre e ajuste o campo de upload de arquivos nos controles do n√≥
        function createMediaControls(nodeId, nodeData) {
            const container = document.createElement('div');
            container.className = 'media-controls';
            
            // Tipo de m√≠dia
            const mediaTypeSelect = createSelectField('Tipo de M√≠dia', 'messageType', nodeData.messageType || 'text', [
                { value: 'text', text: 'Somente Texto' },
                { value: 'image', text: 'Imagem' },
                { value: 'video', text: 'V√≠deo' },
                { value: 'audio', text: '√Åudio' },
                { value: 'document', text: 'Documento' }
            ], nodeId);
            container.appendChild(mediaTypeSelect);
            
            // Arquivo de m√≠dia
            const mediaFileContainer = document.createElement('div');
            mediaFileContainer.className = 'form-group media-file-container';
            mediaFileContainer.style.display = (nodeData.messageType && nodeData.messageType !== 'text') ? 'block' : 'none';
            
            const mediaFileLabel = document.createElement('label');
            mediaFileLabel.textContent = 'Arquivo de M√≠dia:';
            mediaFileContainer.appendChild(mediaFileLabel);
            
            // Adiciona informa√ß√µes do arquivo atual (se existir)
            if (nodeData.mediaFileName) {
                const currentFileInfo = document.createElement('div');
                currentFileInfo.className = 'current-file-info';
                currentFileInfo.innerHTML = `<span>Arquivo atual: ${escapeHTML(nodeData.mediaFileName)}</span>`;
                
                // Bot√£o para excluir o arquivo
                const deleteButton = document.createElement('button');
                deleteButton.type = 'button';
                deleteButton.className = 'delete-media-btn';
                deleteButton.innerHTML = '<i class="fas fa-trash"></i>';
                deleteButton.onclick = function() {
                    // Marca o arquivo para exclus√£o
                    tempNodeData[nodeId].deleteMedia = true;
                    delete tempNodeData[nodeId].mediaFile;
                    delete tempNodeData[nodeId].mediaPreviewUrl;
                    // Oculta a informa√ß√£o do arquivo atual
                    currentFileInfo.style.display = 'none';
                    // Mostra o input de arquivo
                    fileInput.style.display = 'block';
                    applyChangesButton.style.display = 'block';
                };
                currentFileInfo.appendChild(deleteButton);
                mediaFileContainer.appendChild(currentFileInfo);
            }
            
            // Input de arquivo
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.id = `media-file-${nodeId}`;
            fileInput.style.display = nodeData.mediaFileName ? 'none' : 'block';
            fileInput.accept = "image/*, video/*, audio/*, application/pdf, application/msword, application/vnd.openxmlformats-officedocument.*";
            fileInput.onchange = function(event) {
                handleFileSelect(nodeId, event);
            };
            mediaFileContainer.appendChild(fileInput);
            
            container.appendChild(mediaFileContainer);
            
            // Controle o display do container de arquivo baseado na sele√ß√£o do tipo de m√≠dia
            const typeSelect = mediaTypeSelect.querySelector('select');
            typeSelect.addEventListener('change', function() {
                const showFileInput = this.value !== 'text';
                mediaFileContainer.style.display = showFileInput ? 'block' : 'none';
                
                // Atualiza o tipo de mensagem nos dados tempor√°rios
                if (!tempNodeData[nodeId]) tempNodeData[nodeId] = {};
                tempNodeData[nodeId].messageType = this.value;
            });
            
            return container;
        }

        function updateNodeVisual(nodeId) {
            const node = editor.getNodeFromId(nodeId);
            if (!node) return;
            
            const nodeData = { ...node.data };
            
            // Aplicar altera√ß√µes tempor√°rias (se existirem)
            if (tempNodeData[nodeId]) {
                Object.assign(nodeData, tempNodeData[nodeId]);
            }
            
            // Gerar o conte√∫do interno do n√≥
            const contentHTML = generateNodeInnerContentHTML(nodeId, nodeData);
            
            // Atualizar o conte√∫do do n√≥ no editor
            const nodeElement = document.querySelector(`#node-${nodeId} .drawflow_content_node`);
            if (nodeElement) {
                nodeElement.innerHTML = contentHTML;
            }
        }

        // Atualiza a visualiza√ß√£o da m√≠dia no n√≥
        function updateMediaDisplay(nodeId, mediaUrl, fileName) {
            const nodeElement = document.getElementById(`node-${nodeId}`);
            if (!nodeElement) return;

            const mediaPreviewContainer = nodeElement.querySelector('.media-preview-container');
            if (!mediaPreviewContainer) return;

            mediaPreviewContainer.innerHTML = ''; // Limpa preview anterior

            if (mediaUrl && fileName) {
                const fullMediaUrl = mediaUrl.startsWith('http') ? mediaUrl : `${window.location.origin}${mediaUrl}`; // Garante URL completa
                const fileExtension = fileName.split('.').pop().toLowerCase();
                let previewElement;

                if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].includes(fileExtension)) {
                    previewElement = document.createElement('img');
                    previewElement.src = fullMediaUrl;
                    previewElement.alt = fileName;
                    previewElement.style.maxWidth = '100%';
                    previewElement.style.maxHeight = '100px';
                    previewElement.style.display = 'block';
                    previewElement.onerror = () => {
                        console.error("Erro ao carregar imagem:", fullMediaUrl);
                        mediaPreviewContainer.innerHTML = `<small style="color: red;">Erro ao carregar m√≠dia</small>`;
                    };
                } else if (['mp4', 'webm', 'ogg'].includes(fileExtension)) {
                    previewElement = document.createElement('video');
                    previewElement.src = fullMediaUrl;
                    previewElement.controls = true;
                    previewElement.style.maxWidth = '100%';
                    previewElement.style.maxHeight = '100px';
                    previewElement.onerror = () => {
                        console.error("Erro ao carregar v√≠deo:", fullMediaUrl);
                        mediaPreviewContainer.innerHTML = `<small style="color: red;">Erro ao carregar m√≠dia</small>`;
                    };
                } else if (['mp3', 'wav', 'aac'].includes(fileExtension)) {
                    previewElement = document.createElement('audio');
                    previewElement.src = fullMediaUrl;
                    previewElement.controls = true;
                    previewElement.style.width = '100%';
                    previewElement.onerror = () => {
                        console.error("Erro ao carregar √°udio:", fullMediaUrl);
                        mediaPreviewContainer.innerHTML = `<small style="color: red;">Erro ao carregar m√≠dia</small>`;
                    };
                } else {
                    // √çcone gen√©rico para outros tipos de arquivo
                    previewElement = document.createElement('div');
                    previewElement.innerHTML = `<i class="fas fa-file" style="font-size: 2em; margin-right: 5px;"></i> <a href="${fullMediaUrl}" target="_blank" style="font-size: 0.8em; word-break: break-all;">${fileName}</a>`;
                }
                mediaPreviewContainer.appendChild(previewElement);
            } else {
                 mediaPreviewContainer.innerHTML = '<small>Nenhuma m√≠dia anexada</small>'; // Mensagem padr√£o
            }
        }

        function setupMediaUpload(nodeId, nodeData) {
                // Obt√©m o objeto de dados do n√≥
                const nodeObject = editor.getNodeFromId(nodeId);
                console.log("nodeObject setupMediaUpload", nodeObject);
                // Adiciona verifica√ß√£o crucial aqui!
                if (!nodeObject) {
                    console.error(`setupMediaUpload: Node object not found or invalid for ID: ${nodeId}. Skipping media setup.`);
                    return; // Sai da fun√ß√£o se o objeto n√£o for v√°lido
                }
                
                // Obt√©m o elemento DOM relacionado ao n√≥
                const nodeElement = document.getElementById(`node-${nodeId}`);
                if (!nodeElement) {
                    console.error(`setupMediaUpload: Node DOM element not found for ID: ${nodeId}. Skipping media setup.`);
                    return; // Sai da fun√ß√£o se o elemento DOM n√£o for encontrado
                }

                const fileInput = nodeElement.querySelector(`#file-input-${nodeId}`);
                const removeButton = nodeElement.querySelector(`#remove-media-${nodeId}`);
                const mediaPreviewContainer = nodeElement.querySelector('.media-preview-container');

                // Estado inicial da m√≠dia (para checar mudan√ßas)
                let initialMediaUrl = nodeData.mediaUrl || null;
                let initialFileName = nodeData.mediaFileName || null;

                // Armazenar o objeto File temporariamente
                let tempFileObject = null;
                let deleteMediaFlag = false; // Flag para marcar exclus√£o

                // Exibir m√≠dia existente ao carregar
                if (nodeData.mediaUrl && nodeData.mediaFileName) {
                    updateMediaDisplay(nodeId, nodeData.mediaUrl, nodeData.mediaFileName);
                    if(removeButton) removeButton.style.display = 'inline-block';
                } else {
                if(mediaPreviewContainer) mediaPreviewContainer.innerHTML = '<small>Nenhuma m√≠dia anexada</small>';
                if(removeButton) removeButton.style.display = 'none';
                }

                if (fileInput) {
                    fileInput.addEventListener('change', (event) => {
                        const file = event.target.files[0];
                        if (file) {
                            tempFileObject = file; // Guarda o objeto File
                            deleteMediaFlag = false; // Se selecionou novo, n√£o deleta
                            updateMediaDisplay(nodeId, URL.createObjectURL(file), file.name); // Preview local
                            if (removeButton) removeButton.style.display = 'inline-block';

                            // Atualiza nodeData para refletir a sele√ß√£o (ainda n√£o salvo)
                            const currentNodeData = editor.getNodeDataFromId(nodeId);
                            // Verifica se currentNodeData e currentNodeData.data existem
                            if (currentNodeData && currentNodeData.data) {
                                currentNodeData.data._tempFile = tempFileObject; // Marca√ß√£o interna
                                currentNodeData.data._deleteMedia = false;
                                currentNodeData.data.mediaFileName = file.name; // Atualiza nome para display
                                // N√£o atualiza mediaUrl aqui, backend far√° isso
                                editor.updateNodeDataFromId(nodeId, currentNodeData.data);
                            } else {
                                console.error(`Could not get node data for ID: ${nodeId} to store temp file.`);
                            }

                        }
                    });
                }

                if (removeButton) {
                    removeButton.addEventListener('click', () => {
                        tempFileObject = null; // Limpa arquivo tempor√°rio
                        deleteMediaFlag = true; // Marca para exclus√£o no backend
                        if (fileInput) fileInput.value = ''; // Limpa o input
                        updateMediaDisplay(nodeId, null, null); // Limpa preview
                        removeButton.style.display = 'none'; // Esconde bot√£o

                        // Atualiza nodeData para refletir a remo√ß√£o
                        const currentNodeData = editor.getNodeDataFromId(nodeId);
                        // Verifica se currentNodeData e currentNodeData.data existem
                        if (currentNodeData && currentNodeData.data) {
                            currentNodeData.data.mediaUrl = null;
                            currentNodeData.data.mediaFileName = null;
                            currentNodeData.data._tempFile = null; // Limpa marca√ß√£o interna
                            currentNodeData.data._deleteMedia = true; // Marca para exclus√£o
                            editor.updateNodeDataFromId(nodeId, currentNodeData.data);
                        } else {
                            console.error(`Could not get node data for ID: ${nodeId} to mark media for deletion.`);
                        }
                    });
                }
        }

        // Exemplo de como chamar setupMediaUpload ao adicionar/carregar n√≥ 'enviar_mensagem'
        editor.on('nodeCreated', function(id) {
            const node = editor.getNodeFromId(id);
            // Adiciona uma verifica√ß√£o se o n√≥ foi encontrado
            if (!node) {
                console.error(`Node element not found for ID: ${id} during nodeCreated event`);
                return;
            }
            // Tenta obter o nome do n√≥ de forma mais segura
            console.log(node);
            const nodeName = node.name;
            console.log(nodeName);

            if (nodeName === 'enviar_mensagem') {
               const nodeData = node.data; // Pega os dados atuais
               setTimeout(() => {
                setupMediaUpload(node.id, nodeData);
               }, 1000);
            }
            // Configurar outros tipos de n√≥s se necess√°rio
        });

        // Ajuste ao carregar dados existentes
        function loadFlowData(flowData) {
            editor.clear();
            editor.import(flowData);

            // Ap√≥s importar, percorrer os n√≥s e configurar a m√≠dia
            const nodes = flowData.drawflow.Home.data;
            Object.keys(nodes).forEach(nodeId => {
                const nodeInfo = nodes[nodeId];
                 if (nodeInfo.name === 'enviar_mensagem') {
                    // Adiciona um pequeno delay para garantir que o n√≥ foi renderizado
                    setTimeout(() => {
                        setupMediaUpload(nodeId, nodeInfo.data);
                    }, 100);
                }
            });
        }

        // Carregar dados do fluxo se estiver editando
        const flowIdFromUrl = window.location.pathname.split('/').filter(Boolean).pop();
        const isEditingFlow = !isNaN(parseInt(flowIdFromUrl)) || (typeof flowIdFromUrl === 'string' && flowIdFromUrl.length > 5 && flowIdFromUrl !== 'drawflow'); // Verifica ID num√©rico ou UUID-like

        if (isEditingFlow) {
            fetch(`/pt/api/flows/${flowIdFromUrl}/`) // Busca os dados do fluxo espec√≠fico
                .then(response => {
                    if (!response.ok) {
                         // Se n√£o encontrar (404) ou outro erro, inicia editor vazio
                        if (response.status === 404) {
                            console.warn(`Fluxo com ID ${flowIdFromUrl} n√£o encontrado. Iniciando editor vazio.`);
                            editor.start(); // Inicia editor vazio
                        } else {
                            throw new Error(`Erro ${response.status}: ${response.statusText}`);
                        }
                         return null; // Retorna null para evitar processamento posterior
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.flow_json) {
                        // Certifica-se que flow_json √© um objeto antes de importar
                        let flowJsonData = data.flow_json;
                        if (typeof flowJsonData === 'string') {
                            try {
                                flowJsonData = JSON.parse(flowJsonData);
                            } catch (e) {
                                console.error("Erro ao parsear flow_json string:", e);
                                Swal.fire('Erro!', 'Formato inv√°lido dos dados do fluxo recebido.', 'error');
                                editor.start(); // Inicia editor vazio em caso de erro
                                return;
                            }
                        }

                        if (typeof flowJsonData === 'object' && flowJsonData.drawflow) {
                            // Armazena vari√°veis de usu√°rio globalmente se existirem
                            if (data.userVariables && typeof data.userVariables === 'object') {
                                window.userVariables = data.userVariables;
                                populateUserVariablesUI(window.userVariables); // Atualiza a UI de vari√°veis
                            } else {
                                window.userVariables = []; // Inicializa se n√£o vierem
                            }

                             // Atualiza t√≠tulo e descri√ß√£o nos inputs se existirem
                            if (document.getElementById('flowTitleInput')) {
                                document.getElementById('flowTitleInput').value = data.title || '';
                            }
                            if (document.getElementById('flowDescriptionInput')) {
                                document.getElementById('flowDescriptionInput').value = data.description || '';
                            }

                            loadFlowData(flowJsonData); // Chama a fun√ß√£o ajustada para carregar

                        } else {
                           console.error("Dados do fluxo inv√°lidos recebidos do backend:", data);
                           Swal.fire('Erro!', 'Dados do fluxo recebidos est√£o incompletos ou inv√°lidos.', 'error');
                           editor.start(); // Inicia editor vazio
                        }
                    } else if (data === null) {
                        // J√° tratou o 404, n√£o faz nada aqui
                    }
                     else {
                        console.warn("Dados n√£o cont√™m flow_json ou dados inv√°lidos:", data);
                        editor.start(); // Inicia editor vazio se os dados n√£o forem como esperado
                    }
                })
                .catch(error => {
                    console.error('Erro ao carregar dados do fluxo:', error);
                    Swal.fire('Erro!', 'N√£o foi poss√≠vel carregar os dados do fluxo.', 'error');
                    editor.start(); // Inicia editor vazio em caso de erro de fetch
                });
        } else {
            console.log("Nenhum ID de fluxo na URL, iniciando editor vazio.");
            editor.start(); // Nenhum ID na URL, inicia editor vazio
            window.userVariables = []; // Inicializa vari√°veis de usu√°rio vazias
            // populateUserVariablesUI([]);
        }
    </script>
</body>
</html>

